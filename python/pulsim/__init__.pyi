"""Type stubs for PulsimCore High-Performance API."""

from typing import List, Optional
from enum import Enum

__version__: str

# =============================================================================
# Enums
# =============================================================================

class DeviceType(Enum):
    Resistor = ...
    Capacitor = ...
    Inductor = ...
    VoltageSource = ...
    CurrentSource = ...
    Diode = ...
    Switch = ...
    MOSFET = ...
    IGBT = ...
    Transformer = ...

class SolverStatus(Enum):
    Success = ...
    MaxIterationsReached = ...
    SingularMatrix = ...
    NumericalError = ...
    ConvergenceStall = ...
    Diverging = ...

class DCStrategy(Enum):
    Direct = ...
    GminStepping = ...
    SourceStepping = ...
    PseudoTransient = ...
    Auto = ...

class RLCDamping(Enum):
    Underdamped = ...
    Critical = ...
    Overdamped = ...

class DeviceHint(Enum):
    None_ = ...
    DiodeAnode = ...
    DiodeCathode = ...
    MOSFETGate = ...
    MOSFETDrain = ...
    MOSFETSource = ...
    BJTBase = ...
    BJTCollector = ...
    BJTEmitter = ...
    SupplyPositive = ...
    SupplyNegative = ...
    Ground = ...

class SIMDLevel(Enum):
    None_ = ...
    SSE2 = ...
    SSE4 = ...
    AVX = ...
    AVX2 = ...
    AVX512 = ...
    NEON = ...

# =============================================================================
# Device Classes
# =============================================================================

class Resistor:
    def __init__(self, resistance: float, name: str = "") -> None: ...
    def resistance(self) -> float: ...
    def name(self) -> str: ...

class Capacitor:
    def __init__(self, capacitance: float, initial_voltage: float = 0.0, name: str = "") -> None: ...
    def capacitance(self) -> float: ...
    def name(self) -> str: ...
    def set_timestep(self, dt: float) -> None: ...

class Inductor:
    def __init__(self, inductance: float, initial_current: float = 0.0, name: str = "") -> None: ...
    def inductance(self) -> float: ...
    def name(self) -> str: ...
    def set_timestep(self, dt: float) -> None: ...

class VoltageSource:
    def __init__(self, voltage: float, name: str = "") -> None: ...
    def voltage(self) -> float: ...
    def name(self) -> str: ...

class CurrentSource:
    def __init__(self, current: float, name: str = "") -> None: ...
    def current(self) -> float: ...
    def name(self) -> str: ...

# =============================================================================
# Solver Configuration
# =============================================================================

class Tolerances:
    voltage_abstol: float
    voltage_reltol: float
    current_abstol: float
    current_reltol: float
    residual_tol: float

    def __init__(self) -> None: ...
    @staticmethod
    def defaults() -> Tolerances: ...

class NewtonOptions:
    max_iterations: int
    initial_damping: float
    min_damping: float
    auto_damping: bool
    track_history: bool
    check_per_variable: bool
    num_nodes: int
    num_branches: int
    tolerances: Tolerances

    def __init__(self) -> None: ...

class NewtonResult:
    solution: List[float]
    status: SolverStatus
    iterations: int
    final_residual: float
    final_weighted_error: float
    error_message: str

    def __init__(self) -> None: ...
    def success(self) -> bool: ...

# =============================================================================
# Convergence Aids
# =============================================================================

class GminConfig:
    initial_gmin: float
    final_gmin: float
    reduction_factor: float
    max_steps: int
    enable_logging: bool

    def __init__(self) -> None: ...
    def required_steps(self) -> int: ...

class SourceSteppingConfig:
    initial_scale: float
    final_scale: float
    initial_step: float
    min_step: float
    max_step: float
    max_steps: int
    max_failures: int
    enable_logging: bool

    def __init__(self) -> None: ...

class PseudoTransientConfig:
    initial_dt: float
    max_dt: float
    min_dt: float
    dt_increase: float
    dt_decrease: float
    convergence_threshold: float
    max_iterations: int
    enable_logging: bool

    def __init__(self) -> None: ...

class InitializationConfig:
    default_voltage: float
    supply_voltage: float
    diode_forward: float
    mosfet_threshold: float
    use_zero_init: bool
    use_warm_start: bool
    max_random_restarts: int
    random_seed: int
    random_voltage_range: float

    def __init__(self) -> None: ...

class DCConvergenceConfig:
    strategy: DCStrategy
    gmin_config: GminConfig
    source_config: SourceSteppingConfig
    pseudo_config: PseudoTransientConfig
    init_config: InitializationConfig
    enable_random_restart: bool
    max_strategy_attempts: int

    def __init__(self) -> None: ...

class DCAnalysisResult:
    newton_result: NewtonResult
    strategy_used: DCStrategy
    random_restarts: int
    total_newton_iterations: int
    success: bool
    message: str

    def __init__(self) -> None: ...

# =============================================================================
# Validation Framework
# =============================================================================

class RCAnalytical:
    def __init__(self, R: float, C: float, V_initial: float, V_final: float) -> None: ...
    def tau(self) -> float: ...
    def voltage(self, t: float) -> float: ...
    def current(self, t: float) -> float: ...
    def waveform(self, t_start: float, t_end: float, dt: float) -> List[float]: ...

class RLAnalytical:
    def __init__(self, R: float, L: float, V_source: float, I_initial: float) -> None: ...
    def tau(self) -> float: ...
    def I_final(self) -> float: ...
    def current(self, t: float) -> float: ...
    def voltage_R(self, t: float) -> float: ...
    def voltage_L(self, t: float) -> float: ...
    def waveform(self, t_start: float, t_end: float, dt: float) -> List[float]: ...

class RLCAnalytical:
    def __init__(self, R: float, L: float, C: float, V_source: float, V_initial: float, I_initial: float) -> None: ...
    def omega_0(self) -> float: ...
    def zeta(self) -> float: ...
    def alpha(self) -> float: ...
    def damping_type(self) -> RLCDamping: ...
    def voltage(self, t: float) -> float: ...
    def current(self, t: float) -> float: ...
    def waveform(self, t_start: float, t_end: float, dt: float) -> List[float]: ...

class ValidationResult_v2:
    test_name: str
    passed: bool
    max_error: float
    rms_error: float
    max_relative_error: float
    mean_error: float
    num_points: int
    error_threshold: float

    def __init__(self) -> None: ...
    def to_string(self) -> str: ...

def compare_waveforms(name: str, simulated: List[tuple[float, float]], analytical: List[tuple[float, float]], threshold: float = 0.001) -> ValidationResult_v2: ...
def export_validation_csv(results: List[ValidationResult_v2]) -> str: ...
def export_validation_json(results: List[ValidationResult_v2]) -> str: ...

# =============================================================================
# Benchmark Framework
# =============================================================================

class BenchmarkTiming:
    name: str
    iterations: int

    def __init__(self) -> None: ...
    def average_ms(self) -> float: ...
    def min_ms(self) -> float: ...
    def max_ms(self) -> float: ...
    def total_ms(self) -> float: ...

class BenchmarkResult:
    circuit_name: str
    num_nodes: int
    num_devices: int
    num_timesteps: int
    timing: BenchmarkTiming
    simulation_time: float

    def __init__(self) -> None: ...
    def timesteps_per_second(self) -> float: ...
    def to_string(self) -> str: ...

def export_benchmark_csv(results: List[BenchmarkResult]) -> str: ...
def export_benchmark_json(results: List[BenchmarkResult]) -> str: ...

# =============================================================================
# Integration Methods
# =============================================================================

class BDFOrderConfig:
    min_order: int
    max_order: int
    initial_order: int
    order_increase_threshold: float
    order_decrease_threshold: float
    steps_before_increase: int
    enable_auto_order: bool

    def __init__(self) -> None: ...

class TimestepConfig:
    dt_min: float
    dt_max: float
    dt_initial: float
    safety_factor: float
    error_tolerance: float
    growth_factor: float
    shrink_factor: float
    max_rejections: int
    k_p: float
    k_i: float

    def __init__(self) -> None: ...
    @staticmethod
    def defaults() -> TimestepConfig: ...
    @staticmethod
    def conservative() -> TimestepConfig: ...
    @staticmethod
    def aggressive() -> TimestepConfig: ...

# =============================================================================
# High-Performance Features
# =============================================================================

class LinearSolverConfig:
    pivot_tolerance: float
    reuse_symbolic: bool
    detect_pattern_change: bool
    deterministic_pivoting: bool

    def __init__(self) -> None: ...

def detect_simd_level() -> SIMDLevel: ...
def simd_vector_width() -> int: ...
def solver_status_to_string(status: SolverStatus) -> str: ...
