{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PulsimCore DocumentationPulsimCore Backend","text":"<p>High-performance power electronics simulation backend with a Python-first runtime, versioned YAML netlists, and robust convergence tooling.</p> <p>Recommended surface: <code>import pulsim</code> + <code>schema: pulsim-v1</code>.</p> Get Started API Reference Examples"},{"location":"#what-you-can-do-with-pulsimcore","title":"What You Can Do With PulsimCore","text":"<ul> <li>:material-rocket-launch-outline: Run simulations from Python</li> </ul> <p>Build locally or install from package, then execute transient runs through <code>Simulator</code>.</p> <p>Getting Started</p> <ul> <li>:material-file-code-outline: Drive the backend with YAML netlists</li> </ul> <p>Keep simulations reproducible and versioned with <code>pulsim-v1</code> schema.</p> <p>Netlist YAML Format</p> <ul> <li>:material-sine-wave: Model switched converters and control loops</li> </ul> <p>Use mixed-domain blocks, event handling, and duty callbacks in production-like scenarios.</p> <p>Examples and Results</p> <ul> <li>:material-chart-line: Measure performance and parity</li> </ul> <p>Validate runtime and waveform fidelity against benchmark baselines and SPICE tools.</p> <p>Benchmarks and Parity</p> <ul> <li>:material-api: Integrate through a typed API</li> </ul> <p>Navigate classes, options, and enums generated from the package interface.</p> <p>API Reference</p> <ul> <li>:material-tools: Operate docs and release pipeline</li> </ul> <p>Publish versioned docs in GitHub Pages and keep strict docs checks in CI.</p> <p>Docs Versioning and Release</p>"},{"location":"#backend-in-one-command","title":"Backend In One Command","text":"<pre><code>PYTHONPATH=build/python python3 -c \"import pulsim as ps; print(ps.__version__)\"\n</code></pre>"},{"location":"#recommended-learning-path","title":"Recommended Learning Path","text":"<ol> <li>Start with Getting Started.</li> <li>Follow the User Guide to understand the canonical runtime flow.</li> <li>Run Examples and Results end-to-end.</li> <li>Use Benchmarks and Parity to set CI quality gates.</li> <li>Integrate against API Reference.</li> </ol>"},{"location":"api-reference/","title":"API Reference","text":"<p>This page is generated from the <code>pulsim</code> package surface (stubs + public exports).</p> <p>Canonical usage</p> <p>For new integrations, prefer <code>YamlParser</code> + <code>SimulationOptions</code> + <code>Simulator</code>.</p>"},{"location":"api-reference/#circuit-runtime","title":"Circuit Runtime","text":""},{"location":"api-reference/#pulsim.Circuit","title":"Circuit","text":"<pre><code>Circuit()\n</code></pre>"},{"location":"api-reference/#pulsim.VirtualComponent","title":"VirtualComponent","text":"<pre><code>VirtualComponent()\n</code></pre>"},{"location":"api-reference/#pulsim.MixedDomainStepResult","title":"MixedDomainStepResult","text":"<pre><code>MixedDomainStepResult()\n</code></pre>"},{"location":"api-reference/#pulsim.VirtualChannelMetadata","title":"VirtualChannelMetadata","text":"<pre><code>VirtualChannelMetadata()\n</code></pre>"},{"location":"api-reference/#linear-devices","title":"Linear Devices","text":""},{"location":"api-reference/#pulsim.Resistor","title":"Resistor","text":"<pre><code>Resistor(resistance: float, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.Capacitor","title":"Capacitor","text":"<pre><code>Capacitor(capacitance: float, initial_voltage: float = 0.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.Inductor","title":"Inductor","text":"<pre><code>Inductor(inductance: float, initial_current: float = 0.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.VoltageSource","title":"VoltageSource","text":"<pre><code>VoltageSource(voltage: float, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.CurrentSource","title":"CurrentSource","text":"<pre><code>CurrentSource(current: float, name: str = '')\n</code></pre>"},{"location":"api-reference/#nonlinear-and-switching-devices","title":"Nonlinear and Switching Devices","text":""},{"location":"api-reference/#pulsim.IdealDiode","title":"IdealDiode","text":"<pre><code>IdealDiode(name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.IdealSwitch","title":"IdealSwitch","text":"<pre><code>IdealSwitch(name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.MOSFETParams","title":"MOSFETParams","text":"<pre><code>MOSFETParams()\n</code></pre>"},{"location":"api-reference/#pulsim.MOSFET","title":"MOSFET","text":"<pre><code>MOSFET(params: MOSFETParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.IGBTParams","title":"IGBTParams","text":"<pre><code>IGBTParams()\n</code></pre>"},{"location":"api-reference/#pulsim.IGBT","title":"IGBT","text":"<pre><code>IGBT(params: IGBTParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#time-varying-sources","title":"Time-Varying Sources","text":""},{"location":"api-reference/#pulsim.PWMParams","title":"PWMParams","text":"<pre><code>PWMParams()\n</code></pre>"},{"location":"api-reference/#pulsim.PWMVoltageSource","title":"PWMVoltageSource","text":"<pre><code>PWMVoltageSource(params: PWMParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.SineParams","title":"SineParams","text":"<pre><code>SineParams()\n</code></pre>"},{"location":"api-reference/#pulsim.SineVoltageSource","title":"SineVoltageSource","text":"<pre><code>SineVoltageSource(params: SineParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.RampParams","title":"RampParams","text":"<pre><code>RampParams()\n</code></pre>"},{"location":"api-reference/#pulsim.RampGenerator","title":"RampGenerator","text":"<pre><code>RampGenerator(params: RampParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.PulseParams","title":"PulseParams","text":"<pre><code>PulseParams()\n</code></pre>"},{"location":"api-reference/#pulsim.PulseVoltageSource","title":"PulseVoltageSource","text":"<pre><code>PulseVoltageSource(params: PulseParams, name: str = '')\n</code></pre>"},{"location":"api-reference/#control-and-signal-blocks","title":"Control and Signal Blocks","text":""},{"location":"api-reference/#pulsim.PIController","title":"PIController","text":"<pre><code>PIController(kp: float = 1.0, ki: float = 0.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.PIDController","title":"PIDController","text":"<pre><code>PIDController(kp: float = 1.0, ki: float = 0.0, kd: float = 0.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.Comparator","title":"Comparator","text":"<pre><code>Comparator(threshold: float = 0.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.SampleHold","title":"SampleHold","text":"<pre><code>SampleHold(name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.RateLimiter","title":"RateLimiter","text":"<pre><code>RateLimiter(max_rate: float = 1.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.MovingAverageFilter","title":"MovingAverageFilter","text":"<pre><code>MovingAverageFilter(window_size: int = 10, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.HysteresisController","title":"HysteresisController","text":"<pre><code>HysteresisController(upper: float = 1.0, lower: float = -1.0, name: str = '')\n</code></pre>"},{"location":"api-reference/#pulsim.LookupTable1D","title":"LookupTable1D","text":"<pre><code>LookupTable1D(x: List[float], y: List[float], name: str = '')\n</code></pre>"},{"location":"api-reference/#parser-and-simulation-entry-points","title":"Parser and Simulation Entry Points","text":""},{"location":"api-reference/#pulsim.YamlParserOptions","title":"YamlParserOptions","text":"<pre><code>YamlParserOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.YamlParser","title":"YamlParser","text":"<pre><code>YamlParser(options: YamlParserOptions = ...)\n</code></pre>"},{"location":"api-reference/#pulsim.Simulator","title":"Simulator","text":"<pre><code>Simulator(circuit: Circuit, options: SimulationOptions = ...)\n</code></pre>"},{"location":"api-reference/#pulsim.SimulationOptions","title":"SimulationOptions","text":"<pre><code>SimulationOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.SimulationResult","title":"SimulationResult","text":"<pre><code>SimulationResult()\n</code></pre>"},{"location":"api-reference/#solver-configuration","title":"Solver Configuration","text":""},{"location":"api-reference/#pulsim.Tolerances","title":"Tolerances","text":"<pre><code>Tolerances()\n</code></pre>"},{"location":"api-reference/#pulsim.NewtonOptions","title":"NewtonOptions","text":"<pre><code>NewtonOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.NewtonResult","title":"NewtonResult","text":"<pre><code>NewtonResult()\n</code></pre>"},{"location":"api-reference/#pulsim.LinearSolverKind","title":"LinearSolverKind","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.PreconditionerKind","title":"PreconditionerKind","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.IterativeSolverConfig","title":"IterativeSolverConfig","text":"<pre><code>IterativeSolverConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.LinearSolverStackConfig","title":"LinearSolverStackConfig","text":"<pre><code>LinearSolverStackConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.LinearSolverConfig","title":"LinearSolverConfig","text":"<pre><code>LinearSolverConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.LinearSolverTelemetry","title":"LinearSolverTelemetry","text":"<pre><code>LinearSolverTelemetry()\n</code></pre>"},{"location":"api-reference/#integration-and-timestep","title":"Integration and Timestep","text":""},{"location":"api-reference/#pulsim.Integrator","title":"Integrator","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.StepMode","title":"StepMode","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.TimestepMethod","title":"TimestepMethod","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.TimestepConfig","title":"TimestepConfig","text":"<pre><code>TimestepConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.AdvancedTimestepConfig","title":"AdvancedTimestepConfig","text":"<pre><code>AdvancedTimestepConfig()\n</code></pre> <p>               Bases: <code>TimestepConfig</code></p>"},{"location":"api-reference/#pulsim.RichardsonLTEConfig","title":"RichardsonLTEConfig","text":"<pre><code>RichardsonLTEConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.BDFOrderConfig","title":"BDFOrderConfig","text":"<pre><code>BDFOrderConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.StiffnessConfig","title":"StiffnessConfig","text":"<pre><code>StiffnessConfig()\n</code></pre>"},{"location":"api-reference/#dc-and-convergence","title":"DC and Convergence","text":""},{"location":"api-reference/#pulsim.DCStrategy","title":"DCStrategy","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.GminConfig","title":"GminConfig","text":"<pre><code>GminConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.SourceSteppingConfig","title":"SourceSteppingConfig","text":"<pre><code>SourceSteppingConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.PseudoTransientConfig","title":"PseudoTransientConfig","text":"<pre><code>PseudoTransientConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.InitializationConfig","title":"InitializationConfig","text":"<pre><code>InitializationConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.DCConvergenceConfig","title":"DCConvergenceConfig","text":"<pre><code>DCConvergenceConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.DCAnalysisResult","title":"DCAnalysisResult","text":"<pre><code>DCAnalysisResult()\n</code></pre>"},{"location":"api-reference/#periodic-and-harmonic-analysis","title":"Periodic and Harmonic Analysis","text":""},{"location":"api-reference/#pulsim.PeriodicSteadyStateOptions","title":"PeriodicSteadyStateOptions","text":"<pre><code>PeriodicSteadyStateOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.PeriodicSteadyStateResult","title":"PeriodicSteadyStateResult","text":"<pre><code>PeriodicSteadyStateResult()\n</code></pre>"},{"location":"api-reference/#pulsim.HarmonicBalanceOptions","title":"HarmonicBalanceOptions","text":"<pre><code>HarmonicBalanceOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.HarmonicBalanceResult","title":"HarmonicBalanceResult","text":"<pre><code>HarmonicBalanceResult()\n</code></pre>"},{"location":"api-reference/#thermal-and-loss-modeling","title":"Thermal and Loss Modeling","text":""},{"location":"api-reference/#pulsim.ThermalCouplingPolicy","title":"ThermalCouplingPolicy","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.ThermalCouplingOptions","title":"ThermalCouplingOptions","text":"<pre><code>ThermalCouplingOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.ThermalDeviceConfig","title":"ThermalDeviceConfig","text":"<pre><code>ThermalDeviceConfig()\n</code></pre>"},{"location":"api-reference/#pulsim.DeviceThermalTelemetry","title":"DeviceThermalTelemetry","text":"<pre><code>DeviceThermalTelemetry()\n</code></pre>"},{"location":"api-reference/#pulsim.ThermalSummary","title":"ThermalSummary","text":"<pre><code>ThermalSummary()\n</code></pre>"},{"location":"api-reference/#pulsim.SwitchingEnergy","title":"SwitchingEnergy","text":"<pre><code>SwitchingEnergy()\n</code></pre>"},{"location":"api-reference/#pulsim.MOSFETLossParams","title":"MOSFETLossParams","text":"<pre><code>MOSFETLossParams()\n</code></pre>"},{"location":"api-reference/#pulsim.IGBTLossParams","title":"IGBTLossParams","text":"<pre><code>IGBTLossParams()\n</code></pre>"},{"location":"api-reference/#pulsim.DiodeLossParams","title":"DiodeLossParams","text":"<pre><code>DiodeLossParams()\n</code></pre>"},{"location":"api-reference/#pulsim.ConductionLoss","title":"ConductionLoss","text":"<pre><code>ConductionLoss()\n</code></pre>"},{"location":"api-reference/#pulsim.SwitchingLoss","title":"SwitchingLoss","text":"<pre><code>SwitchingLoss()\n</code></pre>"},{"location":"api-reference/#pulsim.LossBreakdown","title":"LossBreakdown","text":"<pre><code>LossBreakdown()\n</code></pre>"},{"location":"api-reference/#pulsim.LossAccumulator","title":"LossAccumulator","text":"<pre><code>LossAccumulator()\n</code></pre>"},{"location":"api-reference/#pulsim.EfficiencyCalculator","title":"EfficiencyCalculator","text":"<pre><code>EfficiencyCalculator()\n</code></pre>"},{"location":"api-reference/#pulsim.LossResult","title":"LossResult","text":"<pre><code>LossResult()\n</code></pre>"},{"location":"api-reference/#pulsim.SystemLossSummary","title":"SystemLossSummary","text":"<pre><code>SystemLossSummary()\n</code></pre>"},{"location":"api-reference/#pulsim.FosterStage","title":"FosterStage","text":"<pre><code>FosterStage()\n</code></pre>"},{"location":"api-reference/#pulsim.FosterNetwork","title":"FosterNetwork","text":"<pre><code>FosterNetwork()\n</code></pre>"},{"location":"api-reference/#pulsim.CauerStage","title":"CauerStage","text":"<pre><code>CauerStage()\n</code></pre>"},{"location":"api-reference/#pulsim.CauerNetwork","title":"CauerNetwork","text":"<pre><code>CauerNetwork()\n</code></pre>"},{"location":"api-reference/#pulsim.ThermalSimulator","title":"ThermalSimulator","text":"<pre><code>ThermalSimulator()\n</code></pre>"},{"location":"api-reference/#pulsim.ThermalLimitMonitor","title":"ThermalLimitMonitor","text":"<pre><code>ThermalLimitMonitor()\n</code></pre>"},{"location":"api-reference/#pulsim.ThermalResult","title":"ThermalResult","text":"<pre><code>ThermalResult()\n</code></pre>"},{"location":"api-reference/#events-and-backend-telemetry","title":"Events and Backend Telemetry","text":""},{"location":"api-reference/#pulsim.SimulationEventType","title":"SimulationEventType","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.SimulationEvent","title":"SimulationEvent","text":"<pre><code>SimulationEvent()\n</code></pre>"},{"location":"api-reference/#pulsim.FallbackReasonCode","title":"FallbackReasonCode","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.FallbackPolicyOptions","title":"FallbackPolicyOptions","text":"<pre><code>FallbackPolicyOptions()\n</code></pre>"},{"location":"api-reference/#pulsim.FallbackTraceEntry","title":"FallbackTraceEntry","text":"<pre><code>FallbackTraceEntry()\n</code></pre>"},{"location":"api-reference/#pulsim.BackendTelemetry","title":"BackendTelemetry","text":"<pre><code>BackendTelemetry()\n</code></pre>"},{"location":"api-reference/#convergence-monitoring","title":"Convergence Monitoring","text":""},{"location":"api-reference/#pulsim.IterationRecord","title":"IterationRecord","text":"<pre><code>IterationRecord()\n</code></pre>"},{"location":"api-reference/#pulsim.ConvergenceHistory","title":"ConvergenceHistory","text":"<pre><code>ConvergenceHistory()\n</code></pre>"},{"location":"api-reference/#pulsim.VariableConvergence","title":"VariableConvergence","text":"<pre><code>VariableConvergence()\n</code></pre>"},{"location":"api-reference/#pulsim.PerVariableConvergence","title":"PerVariableConvergence","text":"<pre><code>PerVariableConvergence()\n</code></pre>"},{"location":"api-reference/#validation-and-benchmarks","title":"Validation and Benchmarks","text":""},{"location":"api-reference/#pulsim.RCAnalytical","title":"RCAnalytical","text":"<pre><code>RCAnalytical(R: float, C: float, V_initial: float, V_final: float)\n</code></pre>"},{"location":"api-reference/#pulsim.RLAnalytical","title":"RLAnalytical","text":"<pre><code>RLAnalytical(R: float, L: float, V_source: float, I_initial: float)\n</code></pre>"},{"location":"api-reference/#pulsim.RLCAnalytical","title":"RLCAnalytical","text":"<pre><code>RLCAnalytical(R: float, L: float, C: float, V_source: float, V_initial: float, I_initial: float)\n</code></pre>"},{"location":"api-reference/#pulsim.RLCDamping","title":"RLCDamping","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.ValidationResult","title":"ValidationResult","text":"<pre><code>ValidationResult()\n</code></pre>"},{"location":"api-reference/#pulsim.compare_waveforms","title":"compare_waveforms","text":"<pre><code>compare_waveforms(name: str, simulated: List[tuple[float, float]], analytical: List[tuple[float, float]], threshold: float = 0.001) -&gt; ValidationResult_v2\n</code></pre>"},{"location":"api-reference/#pulsim.export_validation_csv","title":"export_validation_csv","text":"<pre><code>export_validation_csv(results: List[ValidationResult_v2]) -&gt; str\n</code></pre>"},{"location":"api-reference/#pulsim.export_validation_json","title":"export_validation_json","text":"<pre><code>export_validation_json(results: List[ValidationResult_v2]) -&gt; str\n</code></pre>"},{"location":"api-reference/#pulsim.BenchmarkTiming","title":"BenchmarkTiming","text":"<pre><code>BenchmarkTiming()\n</code></pre>"},{"location":"api-reference/#pulsim.BenchmarkResult","title":"BenchmarkResult","text":"<pre><code>BenchmarkResult()\n</code></pre>"},{"location":"api-reference/#pulsim.export_benchmark_csv","title":"export_benchmark_csv","text":"<pre><code>export_benchmark_csv(results: List[BenchmarkResult]) -&gt; str\n</code></pre>"},{"location":"api-reference/#pulsim.export_benchmark_json","title":"export_benchmark_json","text":"<pre><code>export_benchmark_json(results: List[BenchmarkResult]) -&gt; str\n</code></pre>"},{"location":"api-reference/#pure-python-utilities","title":"Pure-Python Utilities","text":""},{"location":"api-reference/#pulsim.ParsedNetlist","title":"ParsedNetlist  <code>dataclass</code>","text":"<pre><code>ParsedNetlist(circuit: Circuit, title: str = '', warnings: List[NetlistWarning] = list(), models: Dict[str, Any] = dict(), node_map: Dict[str, int] = dict())\n</code></pre> <p>Result of parsing a SPICE netlist.</p>"},{"location":"api-reference/#pulsim.NetlistParseError","title":"NetlistParseError","text":"<pre><code>NetlistParseError(message: str, line_number: Optional[int] = None, line_content: Optional[str] = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Error during netlist parsing with line context.</p>"},{"location":"api-reference/#pulsim.NetlistWarning","title":"NetlistWarning  <code>dataclass</code>","text":"<pre><code>NetlistWarning(line_number: int, line_content: str, message: str)\n</code></pre> <p>Warning from netlist parsing.</p>"},{"location":"api-reference/#pulsim.parse_netlist","title":"parse_netlist","text":"<pre><code>parse_netlist(netlist: str, *, strict: bool = False, default_mosfet_params: Optional[MOSFETParams] = None, default_igbt_params: Optional[IGBTParams] = None) -&gt; Circuit\n</code></pre> <p>Parse a SPICE-like netlist string and return a Pulsim Circuit.</p> <p>Parameters:</p> Name Type Description Default <code>netlist</code> <code>str</code> <p>SPICE netlist string</p> required <code>strict</code> <code>bool</code> <p>If True, raise error on unknown directives; if False, warn and skip</p> <code>False</code> <code>default_mosfet_params</code> <code>Optional[MOSFETParams]</code> <p>Default MOSFET parameters when model not specified</p> <code>None</code> <code>default_igbt_params</code> <code>Optional[IGBTParams]</code> <p>Default IGBT parameters when model not specified</p> <code>None</code> <p>Returns:</p> Type Description <code>Circuit</code> <p>Configured Circuit object ready for simulation</p> <p>Raises:</p> Type Description <code>NetlistParseError</code> <p>On syntax errors or invalid device specifications</p> Example <p>netlist = ''' ... * RC Circuit ... V1 in 0 5 ... R1 in out 1k ... C1 out 0 1u IC=0 ... .end ... ''' ckt = parse_netlist(netlist) print(ckt.num_devices()) 3</p>"},{"location":"api-reference/#pulsim.parse_netlist_verbose","title":"parse_netlist_verbose","text":"<pre><code>parse_netlist_verbose(netlist: str, *, strict: bool = False, default_mosfet_params: Optional[MOSFETParams] = None, default_igbt_params: Optional[IGBTParams] = None) -&gt; ParsedNetlist\n</code></pre> <p>Parse netlist and return detailed result with warnings.</p> <p>Parameters:</p> Name Type Description Default <code>netlist</code> <code>str</code> <p>SPICE netlist string</p> required <code>strict</code> <code>bool</code> <p>If True, raise error on unknown directives</p> <code>False</code> <code>default_mosfet_params</code> <code>Optional[MOSFETParams]</code> <p>Default MOSFET parameters</p> <code>None</code> <code>default_igbt_params</code> <code>Optional[IGBTParams]</code> <p>Default IGBT parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>ParsedNetlist</code> <p>ParsedNetlist object containing:</p> <code>ParsedNetlist</code> <ul> <li>circuit: The built Circuit object</li> </ul> <code>ParsedNetlist</code> <ul> <li>title: Circuit title (first comment line)</li> </ul> <code>ParsedNetlist</code> <ul> <li>warnings: List of NetlistWarning objects</li> </ul> <code>ParsedNetlist</code> <ul> <li>models: Dict of parsed .model definitions</li> </ul> <code>ParsedNetlist</code> <ul> <li>node_map: Dict mapping node names to indices</li> </ul> Example <p>result = parse_netlist_verbose(netlist) print(f\"Title: {result.title}\") for w in result.warnings: ...     print(f\"Warning: {w}\")</p>"},{"location":"api-reference/#pulsim.parse_value","title":"parse_value","text":"<pre><code>parse_value(value_str: str, line_number: Optional[int] = None) -&gt; float\n</code></pre> <p>Parse a value string with optional engineering suffix.</p> Supports <ul> <li>Plain numbers: '100', '1.5', '-3.14'</li> <li>Scientific notation: '1e-6', '1.5E3'</li> <li>Engineering suffixes: '10k', '100u', '1.5meg', '4.7n'</li> </ul> <p>Parameters:</p> Name Type Description Default <code>value_str</code> <code>str</code> <p>Value string to parse</p> required <code>line_number</code> <code>Optional[int]</code> <p>Line number for error reporting</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Parsed float value</p> <p>Raises:</p> Type Description <code>NetlistParseError</code> <p>If value cannot be parsed</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parse_value('100')\n100.0\n&gt;&gt;&gt; parse_value('10k')\n10000.0\n&gt;&gt;&gt; parse_value('1.5meg')\n1500000.0\n&gt;&gt;&gt; parse_value('100u')\n0.0001\n&gt;&gt;&gt; parse_value('4.7n')\n4.7e-09\n</code></pre>"},{"location":"api-reference/#pulsim.SignalEvaluator","title":"SignalEvaluator","text":"<pre><code>SignalEvaluator(circuit_data: dict)\n</code></pre> <p>Evaluates a signal-flow DAG from a circuit description dict each step.</p> <p>The evaluator is deliberately independent of any GUI framework.  It operates on plain Python dicts (the <code>circuit_data</code> format) and uses the native C++ control objects from <code>pulsim._pulsim</code> when available, falling back to pure-Python equivalents otherwise.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator--parameters","title":"Parameters","text":"<p>circuit_data : dict     Circuit description with keys <code>\"components\"</code>, <code>\"wires\"</code>,     <code>\"node_map\"</code>, and <code>\"node_aliases\"</code>.  The format is identical to     the dict produced by the GUI's <code>SimulationService.convert_gui_circuit()</code>,     but it can also be constructed programmatically (no GUI needed).</p>"},{"location":"api-reference/#pulsim.SignalEvaluator--examples","title":"Examples","text":"<p>See module docstring for a complete usage example.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.build","title":"build","text":"<pre><code>build() -&gt; None\n</code></pre> <p>Parse the circuit dict, build the signal DAG, and initialise state.</p> <p>Must be called once before :meth:<code>step</code>.  Call again to rebuild after the circuit description changes.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.build--raises","title":"Raises","text":"<p>AlgebraicLoopError     When a directed cycle exists among the signal-domain blocks.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.has_signal_blocks","title":"has_signal_blocks","text":"<pre><code>has_signal_blocks() -&gt; bool\n</code></pre> <p>Return True if there are any evaluable signal blocks.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.pwm_components","title":"pwm_components","text":"<pre><code>pwm_components() -&gt; dict[str, str]\n</code></pre> <p>Return <code>{comp_id: backend_name}</code> for PWM generators with DUTY_IN connected.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.update_probes","title":"update_probes","text":"<pre><code>update_probes(probe_values: dict[str, float]) -&gt; None\n</code></pre> <p>Inject probe measurements into the evaluator state.</p> <p>Call this after each electrical simulation step with the latest measured values so that feedback blocks (VOLTAGE_PROBE, CURRENT_PROBE) reflect the true circuit state.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.update_probes--parameters","title":"Parameters","text":"<p>probe_values : dict[str, float]     <code>{component_id: measured_value}</code> mapping.  Unrecognised IDs     are silently ignored.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.step","title":"step","text":"<pre><code>step(t: float) -&gt; dict[str, float]\n</code></pre> <p>Evaluate all signal blocks in topological order at time t.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.step--parameters","title":"Parameters","text":"<p>t : float     Current simulation time in seconds.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.step--returns","title":"Returns","text":"<p>dict[str, float]     <code>{comp_id: output_value}</code> for every signal block.     PWM duty values are clamped to <code>[0, 1]</code>.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.get_pwm_duty","title":"get_pwm_duty","text":"<pre><code>get_pwm_duty(comp_id: str) -&gt; float\n</code></pre> <p>Return current computed duty cycle [0, 1] for a PWM component.</p>"},{"location":"api-reference/#pulsim.SignalEvaluator.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset all stateful controller objects (integrators, PI state, etc.).</p>"},{"location":"api-reference/#pulsim.AlgebraicLoopError","title":"AlgebraicLoopError","text":"<pre><code>AlgebraicLoopError(cycle_ids: list[str])\n</code></pre> <p>               Bases: <code>RuntimeError</code></p> <p>Raised when a cycle is detected in the signal-flow graph.</p>"},{"location":"api-reference/#pulsim.AlgebraicLoopError--attributes","title":"Attributes","text":"<p>cycle_ids : list[str]     Component names (or IDs) that form the cycle.</p>"},{"location":"api-reference/#performance-utilities-and-enums","title":"Performance Utilities and Enums","text":""},{"location":"api-reference/#pulsim.SIMDLevel","title":"SIMDLevel","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.DeviceType","title":"DeviceType","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.DeviceHint","title":"DeviceHint","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.SolverStatus","title":"SolverStatus","text":"<p>               Bases: <code>Enum</code></p>"},{"location":"api-reference/#pulsim.detect_simd_level","title":"detect_simd_level","text":"<pre><code>detect_simd_level() -&gt; SIMDLevel\n</code></pre>"},{"location":"api-reference/#pulsim.simd_vector_width","title":"simd_vector_width","text":"<pre><code>simd_vector_width() -&gt; int\n</code></pre>"},{"location":"api-reference/#pulsim.backend_capabilities","title":"backend_capabilities","text":"<pre><code>backend_capabilities() -&gt; Dict[str, bool]\n</code></pre>"},{"location":"api-reference/#pulsim.solver_status_to_string","title":"solver_status_to_string","text":"<pre><code>solver_status_to_string(status: SolverStatus) -&gt; str\n</code></pre>"},{"location":"backend-architecture/","title":"Backend Architecture","text":"<p>PulsimCore is designed as a Python-first simulation backend with a high-performance C++ kernel and a stable YAML workflow for automation.</p>"},{"location":"backend-architecture/#architectural-goals","title":"Architectural Goals","text":"<ul> <li>Deliver deterministic transient simulation for power electronics converters.</li> <li>Keep the user surface simple: <code>import pulsim</code> + YAML netlists.</li> <li>Isolate solver complexity behind typed options and telemetry.</li> <li>Support validation and parity workflows (ngspice/LTspice) from the same backend runtime.</li> </ul>"},{"location":"backend-architecture/#runtime-layers","title":"Runtime Layers","text":"<ol> <li>Python API Layer (<code>python/pulsim</code>)</li> <li>Public package consumed by scripts, notebooks, and CI.</li> <li>Exposes typed classes (<code>Circuit</code>, <code>Simulator</code>, <code>SimulationOptions</code>, <code>YamlParser</code>) and utility modules (<code>netlist</code>, <code>signal_evaluator</code>).</li> <li>Binding Layer (<code>python/bindings.cpp</code>)</li> <li><code>pybind11</code> bridge between Python API and C++ kernel.</li> <li>Preserves zero-copy/low-overhead behavior where possible.</li> <li>Core Kernel (<code>core/</code>)</li> <li>Unified <code>v1</code> execution path for fixed/variable timestep simulation.</li> <li>Nonlinear solves, fallback policies, event handling, thermal coupling, and telemetry.</li> <li>Validation &amp; Benchmarks (<code>benchmarks/</code>)</li> <li>Regression gate for runtime, accuracy, parity, and stress scenarios.</li> </ol>"},{"location":"backend-architecture/#canonical-execution-flow","title":"Canonical Execution Flow","text":"<pre><code>flowchart LR\n    A[\"YAML Netlist\"] --&gt; B[\"YamlParser\"]\n    B --&gt; C[\"Circuit + SimulationOptions\"]\n    C --&gt; D[\"Simulator.run_transient(...)\"]\n    D --&gt; E[\"SimulationResult\"]\n    E --&gt; F[\"Waveforms / Telemetry / KPI Gates\"]\n</code></pre>"},{"location":"backend-architecture/#why-this-design-works-for-production","title":"Why This Design Works for Production","text":"<ul> <li>Stable user entrypoint: product-facing surface stays in Python even while kernel internals evolve.</li> <li>Performance isolation: critical numerics remain in C++ while orchestration stays scriptable.</li> <li>Observability built-in: fallback trace, linear solver telemetry, and event diagnostics are first-class outputs.</li> <li>Automation-ready: benchmarks and parity scripts emit machine-readable artifacts (<code>*.json</code>, <code>*.csv</code>) for CI gates.</li> </ul>"},{"location":"backend-architecture/#extension-boundaries","title":"Extension Boundaries","text":"<p>You can safely extend at the following boundaries:</p> <ul> <li>Add new YAML fields in parser with strict diagnostics.</li> <li>Add new virtual channels and telemetry fields in runtime outputs.</li> <li>Add new benchmark scenarios in <code>benchmarks/</code> and gate with <code>kpi_gate.py</code>.</li> </ul> <p>Avoid changing the canonical <code>Simulator</code> execution contract unless accompanied by migration notes and compatibility tests.</p>"},{"location":"benchmarks-and-parity/","title":"Benchmarks and Parity","text":"<p>Use these workflows to guard runtime, numerical stability, and external parity.</p>"},{"location":"benchmarks-and-parity/#1-standard-benchmark-suite","title":"1) Standard Benchmark Suite","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --output-dir benchmarks/out\n</code></pre> <p>For switching-heavy converter cases:</p> <pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --only buck_switching boost_switching_complex interleaved_buck_3ph buck_mosfet_nonlinear \\\n  --output-dir benchmarks/out_converters\n</code></pre>"},{"location":"benchmarks-and-parity/#2-solverintegrator-validation-matrix","title":"2) Solver/Integrator Validation Matrix","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/validation_matrix.py \\\n  --output-dir benchmarks/matrix\n</code></pre> <p>This matrix is useful to detect solver regressions across fixed/variable timestep modes.</p>"},{"location":"benchmarks-and-parity/#3-external-parity","title":"3) External Parity","text":""},{"location":"benchmarks-and-parity/#ngspice","title":"ngspice","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_ngspice.py \\\n  --backend ngspice \\\n  --output-dir benchmarks/ngspice_out\n</code></pre>"},{"location":"benchmarks-and-parity/#ltspice","title":"LTspice","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_ngspice.py \\\n  --backend ltspice \\\n  --ltspice-exe \"/Applications/LTspice.app/Contents/MacOS/LTspice\" \\\n  --output-dir benchmarks/ltspice_out\n</code></pre>"},{"location":"benchmarks-and-parity/#4-tiered-stress-suite","title":"4) Tiered Stress Suite","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/stress_suite.py \\\n  --output-dir benchmarks/stress_out\n</code></pre> <p>Electro-thermal stress variant:</p> <pre><code>PYTHONPATH=build/python python3 benchmarks/stress_suite.py \\\n  --benchmarks benchmarks/electrothermal_benchmarks.yaml \\\n  --catalog benchmarks/electrothermal_stress_catalog.yaml \\\n  --output-dir benchmarks/stress_out_electrothermal\n</code></pre>"},{"location":"benchmarks-and-parity/#5-gui-to-backend-parity-gate","title":"5) GUI-to-Backend Parity Gate","text":"<pre><code>PYTHONPATH=build/python pytest -q python/tests/test_gui_component_parity.py\nPYTHONPATH=build/python pytest -q python/tests/test_runtime_bindings.py\n./build-test/core/pulsim_simulation_tests \"[v1][yaml][gui-parity]\"\n</code></pre>"},{"location":"benchmarks-and-parity/#6-kpi-regression-gate","title":"6) KPI Regression Gate","text":"<pre><code>python3 benchmarks/kpi_gate.py \\\n  --bench-results benchmarks/out/results.json \\\n  --stress-summary benchmarks/stress_out/stress_summary.json \\\n  --report-out benchmarks/out/kpi_gate_report.json \\\n  --print-report\n</code></pre> <p>Baseline and threshold files:</p> <ul> <li><code>benchmarks/kpi_baselines/phase0_2026-02-23/kpi_baseline.json</code></li> <li><code>benchmarks/kpi_thresholds.yaml</code></li> </ul>"},{"location":"benchmarks-and-parity/#artifact-contract","title":"Artifact Contract","text":"<p>These files are the recommended CI contract:</p> <ul> <li>benchmark: <code>results.csv</code>, <code>results.json</code>, <code>summary.json</code></li> <li>parity: <code>parity_results.csv</code>, <code>parity_results.json</code>, <code>parity_summary.json</code></li> <li>stress: <code>stress_results.csv</code>, <code>stress_results.json</code>, <code>stress_summary.json</code></li> </ul> <p>Primary hybrid/electro-thermal KPI keys emitted in benchmark outputs:</p> <ul> <li><code>state_space_primary_ratio</code></li> <li><code>dae_fallback_ratio</code></li> <li><code>loss_energy_balance_error</code></li> <li><code>thermal_peak_temperature_delta</code></li> </ul>"},{"location":"configuration/","title":"Configuration Guide","text":"<p>Este guia concentra as configura\u00e7\u00f5es que mais impactam converg\u00eancia, tempo de simula\u00e7\u00e3o e fidelidade.</p>"},{"location":"configuration/#bloco-simulation","title":"Bloco <code>simulation</code>","text":"<p>Configura\u00e7\u00e3o base:</p> <pre><code>simulation:\n  tstart: 0.0\n  tstop: 2e-3\n  dt: 1e-6\n  step_mode: variable   # fixed | variable\n  dt_min: 1e-10\n  dt_max: 1e-4\n  integrator: trbdf2\n</code></pre> <p>Campos pr\u00e1ticos:</p> <ul> <li><code>tstop</code>, <code>dt</code>: resolu\u00e7\u00e3o e dura\u00e7\u00e3o.</li> <li><code>step_mode</code>: <code>fixed</code> para grade determin\u00edstica; <code>variable</code> para adapta\u00e7\u00e3o autom\u00e1tica.</li> <li><code>adaptive_timestep</code>: override avan\u00e7ado (evite no fluxo can\u00f4nico; prefira <code>step_mode</code>).</li> <li><code>integrator</code>: <code>trapezoidal</code>, <code>bdf1..bdf5</code>, <code>trbdf2</code>, <code>rosenbrockw</code>, <code>sdirk2</code>.</li> </ul> <p>Observa\u00e7\u00e3o de migra\u00e7\u00e3o:</p> <ul> <li><code>simulation.backend</code> e <code>simulation.sundials</code> s\u00e3o campos legados para transiente e n\u00e3o   fazem parte do caminho suportado; use <code>simulation.step_mode</code>.</li> </ul>"},{"location":"configuration/#solver-linear-em-runtime","title":"Solver linear em runtime","text":"<pre><code>simulation:\n  solver:\n    order: [klu, gmres]\n    fallback_order: [sparselu]\n    allow_fallback: true\n    auto_select: true\n    size_threshold: 400\n    nnz_threshold: 2500\n    diag_min_threshold: 1e-12\n</code></pre> <p>Quando usar:</p> <ul> <li><code>KLU</code>/<code>SparseLU</code>: redes pequenas/m\u00e9dias com robustez alta.</li> <li><code>GMRES</code>/<code>BiCGSTAB</code>: redes grandes e esparsas.</li> <li><code>fallback_order</code>: prote\u00e7\u00e3o para casos dif\u00edceis.</li> </ul>"},{"location":"configuration/#iterativo-e-precondicionador","title":"Iterativo e precondicionador","text":"<pre><code>simulation:\n  solver:\n    iterative:\n      max_iterations: 300\n      tolerance: 1e-8\n      restart: 40\n      preconditioner: ilut\n      ilut_drop_tolerance: 1e-3\n      ilut_fill_factor: 10\n      enable_scaling: true\n      scaling_floor: 1e-12\n</code></pre> <p>Regras r\u00e1pidas:</p> <ul> <li>comece com <code>ilut</code> em conversores maiores;</li> <li>aumente <code>max_iterations</code> se ficar pr\u00f3ximo de convergir;</li> <li><code>enable_scaling</code> ajuda matrizes mal condicionadas.</li> </ul>"},{"location":"configuration/#newton-fallback-e-robustez","title":"Newton, fallback e robustez","text":"<pre><code>simulation:\n  newton:\n    max_iterations: 60\n    enable_limiting: true\n    max_voltage_step: 2.0\n    max_current_step: 5.0\n</code></pre> <p>Complementos \u00fateis:</p> <ul> <li><code>max_step_retries</code>: quantas tentativas por passo.</li> <li><code>gmin_fallback</code>: refor\u00e7o de robustez em regi\u00f5es dif\u00edceis.</li> <li><code>fallback_policy</code>: rastreio e pol\u00edtica de retry (<code>fallback_trace</code>).</li> </ul>"},{"location":"configuration/#perdas-e-termico","title":"Perdas e t\u00e9rmico","text":"<pre><code>simulation:\n  enable_losses: true\n  thermal:\n    enable: true\n    ambient: 25.0\n    policy: loss_with_temperature_scaling\n    default_rth: 1.5\n    default_cth: 0.02\n</code></pre> <p>Sa\u00eddas relevantes:</p> <ul> <li><code>result.loss_summary</code></li> <li><code>result.thermal_summary</code></li> <li><code>result.events</code> para inspe\u00e7\u00e3o de chaveamento/eventos.</li> </ul>"},{"location":"configuration/#estrategias-de-configuracao","title":"Estrat\u00e9gias de configura\u00e7\u00e3o","text":""},{"location":"configuration/#debug-rapido","title":"Debug r\u00e1pido","text":"<ul> <li><code>step_mode: fixed</code></li> <li><code>integrator: trapezoidal</code></li> <li><code>order: [sparselu]</code></li> </ul>"},{"location":"configuration/#producao-robusta","title":"Produ\u00e7\u00e3o robusta","text":"<ul> <li><code>step_mode: variable</code></li> <li><code>integrator: trbdf2</code> ou <code>rosenbrockw</code></li> <li><code>order: [klu, gmres]</code></li> <li><code>fallback_order: [sparselu]</code></li> </ul>"},{"location":"convergence-tuning-guide/","title":"Convergence Tuning Guide (Python + YAML)","text":"<p>Este guia foca no runtime suportado: Python + YAML (<code>pulsim-v1</code>).</p>"},{"location":"convergence-tuning-guide/#sintomas-comuns","title":"Sintomas comuns","text":"<ul> <li>Falha no ponto de opera\u00e7\u00e3o DC (<code>dc_operating_point</code>).</li> <li>Muitos <code>timestep_rejections</code> no transiente.</li> <li>Queda para fallback linear com frequ\u00eancia alta.</li> <li>Passos muito pequenos e simula\u00e7\u00e3o lenta.</li> </ul>"},{"location":"convergence-tuning-guide/#checklist-rapido","title":"Checklist r\u00e1pido","text":"<ol> <li>Garanta caminho DC para o terra (evite n\u00f3s flutuantes).</li> <li>Use <code>simulation.solver.order</code> e <code>fallback_order</code> expl\u00edcitos.</li> <li>Em circuitos stiff, prefira <code>integrator: trbdf2</code> ou <code>rosenbrockw</code>.</li> <li>Ative precondicionador ILUT para malhas grandes.</li> <li>Use <code>adaptive_timestep: false</code> quando quiser baseline determin\u00edstico.</li> </ol>"},{"location":"convergence-tuning-guide/#verificar-backends-compilados","title":"Verificar backends compilados","text":"<p>No Python:</p> <pre><code>import pulsim as ps\nprint(ps.backend_capabilities())\n# {'klu': True, 'hypre_amg': True/False, 'sundials': True/False}\n</code></pre> <p>Observa\u00e7\u00e3o: <code>sundials=True</code> indica apenas suporte compilado opcional. No caminho suportado de transiente, use o core nativo com <code>simulation.step_mode</code> (<code>fixed|variable</code>), sem sele\u00e7\u00e3o de backend legado.</p>"},{"location":"convergence-tuning-guide/#exemplo-de-configuracao-robusta","title":"Exemplo de configura\u00e7\u00e3o robusta","text":"<pre><code>schema: pulsim-v1\nversion: 1\nsimulation:\n  tstart: 0.0\n  tstop: 2e-3\n  dt: 1e-6\n  step_mode: variable\n  dt_min: 1e-10\n  dt_max: 5e-5\n  adaptive_timestep: true  # override avan\u00e7ado\n  integrator: trbdf2\n\n  solver:\n    order: [klu, gmres]\n    fallback_order: [sparselu]\n    allow_fallback: true\n    auto_select: true\n    size_threshold: 400\n    nnz_threshold: 2500\n    diag_min_threshold: 1e-12\n    iterative:\n      max_iterations: 300\n      tolerance: 1e-8\n      restart: 40\n      preconditioner: ilut\n      ilut_drop_tolerance: 1e-3\n      ilut_fill_factor: 10\n      enable_scaling: true\n      scaling_floor: 1e-12\n\n  newton:\n    max_iterations: 60\n    enable_limiting: true\n    max_voltage_step: 2.0\n    max_current_step: 5.0\n</code></pre>"},{"location":"convergence-tuning-guide/#ajustes-por-cenario","title":"Ajustes por cen\u00e1rio","text":""},{"location":"convergence-tuning-guide/#buckboost-com-chaveamento-rapido","title":"Buck/boost com chaveamento r\u00e1pido","text":"<ul> <li><code>integrator: trbdf2</code></li> <li><code>dt</code> inicial pequeno (ordem de 1/50 a 1/200 do per\u00edodo de comuta\u00e7\u00e3o)</li> <li><code>enable_events: true</code></li> </ul>"},{"location":"convergence-tuning-guide/#malha-grande-com-muitos-passivos","title":"Malha grande com muitos passivos","text":"<ul> <li><code>order: [gmres, klu]</code> ou <code>[klu, gmres]</code> (teste as duas)</li> <li>ILUT ligado</li> <li>aumente <code>iterative.max_iterations</code></li> </ul>"},{"location":"convergence-tuning-guide/#problema-quase-singular","title":"Problema quase singular","text":"<ul> <li>aumente <code>diag_min_threshold</code></li> <li>reduza <code>max_voltage_step</code></li> <li>aumente <code>gmin_fallback</code> e <code>max_step_retries</code></li> </ul>"},{"location":"convergence-tuning-guide/#observabilidade-para-diagnostico","title":"Observabilidade para diagn\u00f3stico","text":"<p>No resultado transiente, acompanhe:</p> <ul> <li><code>result.newton_iterations_total</code></li> <li><code>result.timestep_rejections</code></li> <li><code>result.linear_solver_telemetry.total_fallbacks</code></li> <li><code>result.fallback_trace</code></li> </ul> <p>Esses campos s\u00e3o essenciais para comparar tuning entre cen\u00e1rios e evitar regress\u00e3o.</p>"},{"location":"convergence-tuning-guide/#estrategia-de-validacao","title":"Estrat\u00e9gia de valida\u00e7\u00e3o","text":"<ol> <li>Ajuste em circuito pequeno de refer\u00eancia.</li> <li>Replique no benchmark matrix.</li> <li>Confirme em <code>ngspice</code> e depois <code>LTspice</code>.</li> <li>Execute stress tiers A/B/C antes de promover configura\u00e7\u00e3o.</li> </ol>"},{"location":"device-models/","title":"Pulsim Device Model Reference","text":"<p>This document provides detailed information about all device models supported by Pulsim, including their equations, parameters, and usage guidelines.</p>"},{"location":"device-models/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Passive Components</li> <li>Sources</li> <li>Semiconductor Devices</li> <li>Switching Devices</li> <li>Magnetic Components</li> <li>Thermal Models</li> <li>Device Library</li> </ol>"},{"location":"device-models/#passive-components","title":"Passive Components","text":""},{"location":"device-models/#resistor","title":"Resistor","text":"<p>Symbol: R Equation: V = I \u00d7 R</p> <p>The resistor is modeled as a linear conductance G = 1/R in the MNA matrix.</p> <p>MNA Stamp: <pre><code>     n+    n-\nn+ [ +G   -G  ]\nn- [ -G   +G  ]\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Range | Description | |-----------|--------|------|-------|-------------| | value | R | \u03a9 | &gt; 0 | Resistance |</p>"},{"location":"device-models/#capacitor","title":"Capacitor","text":"<p>Symbol: C Equation: I = C \u00d7 dV/dt</p> <p>Pulsim uses the companion model approach for time integration.</p> <p>Backward Euler Companion Model: <pre><code>I_eq = (C/dt) \u00d7 V_new - (C/dt) \u00d7 V_old\nG_eq = C/dt\n</code></pre></p> <p>Trapezoidal Companion Model: <pre><code>I_eq = (2C/dt) \u00d7 V_new - (2C/dt) \u00d7 V_old - I_old\nG_eq = 2C/dt\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Range | Description | |-----------|--------|------|-------|-------------| | value | C | F | &gt; 0 | Capacitance | | ic | V\u2080 | V | any | Initial voltage |</p>"},{"location":"device-models/#inductor","title":"Inductor","text":"<p>Symbol: L Equation: V = L \u00d7 dI/dt</p> <p>Backward Euler Companion Model: <pre><code>V_eq = (L/dt) \u00d7 I_new - (L/dt) \u00d7 I_old\nR_eq = L/dt\n</code></pre></p> <p>Trapezoidal Companion Model: <pre><code>V_eq = (2L/dt) \u00d7 I_new - (2L/dt) \u00d7 I_old + V_old\nR_eq = 2L/dt\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Range | Description | |-----------|--------|------|-------|-------------| | value | L | H | &gt; 0 | Inductance | | ic | I\u2080 | A | any | Initial current |</p>"},{"location":"device-models/#sources","title":"Sources","text":""},{"location":"device-models/#dc-voltage-source","title":"DC Voltage Source","text":"<p>Symbol: V Equation: V = V_dc</p> <p>Implemented using a voltage source MNA stamp with an additional equation row.</p> <p>MNA Stamp: <pre><code>      n+    n-    I_v\nn+  [  0    0    +1  ]\nn-  [  0    0    -1  ]\nI_v [ +1   -1     0  ] = V_dc\n</code></pre></p>"},{"location":"device-models/#pulse-voltage-source","title":"Pulse Voltage Source","text":"<p>Waveform Definition: <pre><code>        V2  ____________________\n           /|                  |\\\n          / |                  | \\\n         /  |                  |  \\\n    V1 _/   |                  |   \\_____\n       |    |                  |   |\n       td   tr      pw         tf\n       |&lt;-------- period ----------&gt;|\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | v1 | V\u2081 | V | Low voltage level | | v2 | V\u2082 | V | High voltage level | | td | t_d | s | Delay time | | tr | t_r | s | Rise time | | tf | t_f | s | Fall time | | pw | t_pw | s | Pulse width | | period | T | s | Period |</p>"},{"location":"device-models/#sinusoidal-voltage-source","title":"Sinusoidal Voltage Source","text":"<p>Equation: <pre><code>V(t) = V_o + V_a \u00d7 sin(2\u03c0 \u00d7 f \u00d7 (t - t_d) + \u03c6) \u00d7 e^(-\u03b8(t-t_d))\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | vo | V_o | V | DC offset | | va | V_a | V | Amplitude | | freq | f | Hz | Frequency | | td | t_d | s | Delay | | theta | \u03b8 | 1/s | Damping factor | | phi | \u03c6 | deg | Phase |</p>"},{"location":"device-models/#pwm-source","title":"PWM Source","text":"<p>Generates a pulse-width modulated signal for switching control.</p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | frequency | f_sw | Hz | Switching frequency | | duty | D | - | Duty cycle (0-1) | | phase | \u03c6 | deg | Phase offset | | dead_time | t_dead | s | Dead time between transitions | | inverted | - | bool | Invert output |</p> <p>Dead Time Handling:</p> <p>For complementary switches (e.g., high-side and low-side in half-bridge): <pre><code>S_high: |----ON----|     |----ON----|\nS_low:       |----ON----|     |----ON----|\n        ^dead^      ^dead^\n</code></pre></p>"},{"location":"device-models/#semiconductor-devices","title":"Semiconductor Devices","text":""},{"location":"device-models/#diode-ideal-model","title":"Diode - Ideal Model","text":"<p>Symbol: D Model: ideal</p> <p>Equations: <pre><code>OFF state (V_ak &lt; 0):  I = 0, G = G_off = 1e-9\nON state (V_ak &gt;= 0):  I = V_ak / R_on, G = 1/R_on\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Default | Description | |-----------|--------|------|---------|-------------| | ron | R_on | \u03a9 | 0.001 | On-state resistance | | roff | R_off | \u03a9 | 1e9 | Off-state resistance |</p>"},{"location":"device-models/#diode-shockley-model","title":"Diode - Shockley Model","text":"<p>Symbol: D Model: shockley</p> <p>DC Equation: <pre><code>I_d = I_s \u00d7 (e^(V_d/(n\u00d7V_t)) - 1)\n\nwhere V_t = kT/q \u2248 26mV at 300K\n</code></pre></p> <p>Junction Capacitance: <pre><code>C_j = C_jo / (1 - V_d/V_j)^m   for V_d &lt; FC\u00d7V_j\nC_j = C_jo \u00d7 (1-FC)^(-1-m) \u00d7 (1-FC(1+m) + m\u00d7V_d/V_j)   for V_d &gt;= FC\u00d7V_j\n</code></pre></p> <p>Diffusion Capacitance: <pre><code>C_d = \u03c4_t \u00d7 dI_d/dV_d = \u03c4_t \u00d7 I_s/(n\u00d7V_t) \u00d7 e^(V_d/(n\u00d7V_t))\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Default | Description | |-----------|--------|------|---------|-------------| | is | I_s | A | 1e-14 | Saturation current | | n | n | - | 1.0 | Emission coefficient | | rs | R_s | \u03a9 | 0 | Series resistance | | cjo | C_jo | F | 0 | Zero-bias junction capacitance | | vj | V_j | V | 0.7 | Junction potential | | m | m | - | 0.5 | Grading coefficient | | tt | \u03c4_t | s | 0 | Transit time | | bv | BV | V | \u221e | Breakdown voltage | | ibv | I_BV | A | 1e-10 | Breakdown knee current | | fc | FC | - | 0.5 | Forward-bias capacitance coefficient |</p> <p>Linearization for Newton-Raphson: <pre><code>I_d \u2248 I_d0 + G_d \u00d7 (V_d - V_d0)\nG_d = dI_d/dV_d = I_s/(n\u00d7V_t) \u00d7 e^(V_d0/(n\u00d7V_t))\n</code></pre></p>"},{"location":"device-models/#mosfet-level-1-model","title":"MOSFET - Level 1 Model","text":"<p>Symbol: M (NMOS/PMOS)</p> <p>Operating Regions:</p> <p>Cutoff (V_gs &lt; V_th): <pre><code>I_ds = 0\n</code></pre></p> <p>Linear/Triode (V_gs &gt;= V_th, V_ds &lt; V_gs - V_th): <pre><code>I_ds = K_p \u00d7 (W/L) \u00d7 [(V_gs - V_th) \u00d7 V_ds - V_ds\u00b2/2] \u00d7 (1 + \u03bb \u00d7 V_ds)\n</code></pre></p> <p>Saturation (V_gs &gt;= V_th, V_ds &gt;= V_gs - V_th): <pre><code>I_ds = (K_p/2) \u00d7 (W/L) \u00d7 (V_gs - V_th)\u00b2 \u00d7 (1 + \u03bb \u00d7 V_ds)\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Default | Description | |-----------|--------|------|---------|-------------| | vth | V_th | V | 2.0 | Threshold voltage | | kp | K_p | A/V\u00b2 | 20e-6 | Transconductance parameter | | lambda | \u03bb | 1/V | 0.01 | Channel-length modulation | | w | W | m | 100e-6 | Channel width | | l | L | m | 10e-6 | Channel length |</p> <p>Capacitances: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | cgs | C_gs | F | Gate-source capacitance | | cgd | C_gd | F | Gate-drain (Miller) capacitance | | cds | C_ds | F | Drain-source capacitance |</p> <p>Jacobian Elements for Newton-Raphson: <pre><code>\u2202I_ds/\u2202V_gs = g_m = K_p \u00d7 (W/L) \u00d7 V_ds                    (linear)\n\u2202I_ds/\u2202V_gs = g_m = K_p \u00d7 (W/L) \u00d7 (V_gs - V_th)           (saturation)\n\n\u2202I_ds/\u2202V_ds = g_ds = K_p \u00d7 (W/L) \u00d7 (V_gs - V_th - V_ds)   (linear)\n\u2202I_ds/\u2202V_ds = g_ds = \u03bb \u00d7 I_ds                              (saturation)\n</code></pre></p>"},{"location":"device-models/#power-mosfet-simplified-model","title":"Power MOSFET - Simplified Model","text":"<p>For power electronics simulation, a simplified model using datasheet parameters is more practical.</p> <p>On-State: <pre><code>V_ds = I_ds \u00d7 R_ds(on)(T_j)\n</code></pre></p> <p>Temperature Dependence: <pre><code>R_ds(on)(T_j) = R_ds(on)(25\u00b0C) \u00d7 [1 + TC1\u00d7(T_j-25) + TC2\u00d7(T_j-25)\u00b2]\n</code></pre></p> <p>Typical TC values for Si MOSFETs: - TC1 \u2248 0.005 to 0.01 /\u00b0C - TC2 \u2248 0 (often neglected)</p> <p>Body Diode:</p> <p>The intrinsic body diode is modeled as a fast-recovery diode: <pre><code>I_d = I_s \u00d7 (e^(V_d/(n\u00d7V_t)) - 1)\n</code></pre></p> <p>With reverse recovery: <pre><code>Q_rr = I_F \u00d7 t_rr / 2\nE_rr = Q_rr \u00d7 V_R\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Default | Description | |-----------|--------|------|---------|-------------| | rds_on | R_ds(on) | \u03a9 | - | On-state drain-source resistance | | vth | V_th | V | 3.0 | Gate threshold voltage | | ciss | C_iss | F | - | Input capacitance (C_gs + C_gd) | | coss | C_oss | F | - | Output capacitance (C_gd + C_ds) | | crss | C_rss | F | - | Reverse transfer capacitance (C_gd) | | qg | Q_g | C | - | Total gate charge | | tc1 | TC1 | 1/\u00b0C | 0.007 | Temperature coefficient 1 | | tc2 | TC2 | 1/\u00b0C\u00b2 | 0 | Temperature coefficient 2 |</p>"},{"location":"device-models/#igbt-simplified-model","title":"IGBT - Simplified Model","text":"<p>On-State Voltage: <pre><code>V_ce(sat) = V_ce0 + R_ce \u00d7 I_c\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | vce_sat | V_ce0 | V | On-state voltage at zero current | | rce | R_ce | \u03a9 | On-state resistance | | vth | V_th | V | Gate threshold voltage | | td_on | t_d(on) | s | Turn-on delay time | | tr | t_r | s | Current rise time | | td_off | t_d(off) | s | Turn-off delay time | | tf | t_f | s | Current fall time | | cies | C_ies | F | Input capacitance | | coes | C_oes | F | Output capacitance | | cres | C_res | F | Reverse transfer capacitance |</p>"},{"location":"device-models/#switching-devices","title":"Switching Devices","text":""},{"location":"device-models/#ideal-switch","title":"Ideal Switch","text":"<p>Model: <pre><code>OFF: R = R_off (very high, ~1e9 \u03a9)\nON:  R = R_on (very low, ~1 m\u03a9)\n</code></pre></p> <p>Control Logic: <pre><code>V_control &gt; V_th \u2192 ON\nV_control &lt;= V_th \u2192 OFF\n</code></pre></p> <p>Event Handling:</p> <p>When a switch changes state: 1. Event detected at crossing time 2. Simulation steps back to crossing 3. Matrix is reformulated 4. Integration restarts with new topology</p>"},{"location":"device-models/#magnetic-components","title":"Magnetic Components","text":""},{"location":"device-models/#ideal-transformer","title":"Ideal Transformer","text":"<p>Equations: <pre><code>V_1 = n \u00d7 V_2\nI_1 = -I_2 / n\n\nwhere n = N_1/N_2 (turns ratio)\n</code></pre></p> <p>MNA Implementation:</p> <p>The ideal transformer is implemented using coupled voltage and current sources.</p>"},{"location":"device-models/#transformer-with-parasitics","title":"Transformer with Parasitics","text":"<p>Equivalent Circuit: <pre><code>    R_p    L_lk_p        n:1        L_lk_s    R_s\no---/\\/\\/---LLLL---o    | |    o---LLLL---/\\/\\/---o\n                       | |\n                    L_m ||\n                       | |\no----------------------o    o---------------------o\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | turns_ratio | n | - | Primary to secondary turns ratio | | lm | L_m | H | Magnetizing inductance | | llk_pri | L_lk,p | H | Primary leakage inductance | | llk_sec | L_lk,s | H | Secondary leakage inductance | | rp | R_p | \u03a9 | Primary winding resistance | | rs | R_s | \u03a9 | Secondary winding resistance |</p>"},{"location":"device-models/#thermal-models","title":"Thermal Models","text":""},{"location":"device-models/#foster-network","title":"Foster Network","text":"<p>Pulsim uses the Foster RC network representation for thermal modeling:</p> <pre><code>       R_th1        R_th2        R_th3\nP_loss --/\\/\\/--+--/\\/\\/--+--/\\/\\/--+-- T_ambient\n               |         |         |\n              ===C1     ===C2     ===C3\n               |         |         |\n              GND       GND       GND\n</code></pre> <p>Time Constants: <pre><code>\u03c4_i = R_th_i \u00d7 C_th_i\n</code></pre></p> <p>Transient Response: <pre><code>Z_th(t) = \u03a3 R_th_i \u00d7 (1 - e^(-t/\u03c4_i))\n</code></pre></p> <p>Steady-State: <pre><code>R_th_jc = \u03a3 R_th_i\n</code></pre></p> <p>Parameters: | Parameter | Symbol | Unit | Description | |-----------|--------|------|-------------| | rth | R_th | K/W | Array of thermal resistances | | tau | \u03c4 | s | Array of time constants |</p>"},{"location":"device-models/#temperature-dependent-parameters","title":"Temperature-Dependent Parameters","text":"<p>MOSFET R_ds(on): <pre><code>R_ds(on)(T) = R_ds(on)(25\u00b0C) \u00d7 (T/300)^\u03b1\n\nwhere \u03b1 \u2248 2.0 to 2.5 for silicon\n</code></pre></p> <p>Diode Forward Voltage: <pre><code>V_f(T) = V_f(25\u00b0C) - \u03b1_vf \u00d7 (T - 25)\n\nwhere \u03b1_vf \u2248 2 mV/\u00b0C\n</code></pre></p>"},{"location":"device-models/#device-library","title":"Device Library","text":"<p>Pulsim includes a library of pre-defined device models based on manufacturer datasheets.</p>"},{"location":"device-models/#mosfets","title":"MOSFETs","text":"Model V_ds R_ds(on) I_d Package IRF540N 100V 44m\u03a9 33A TO-220 IRFP460 500V 270m\u03a9 20A TO-247 IPP200N25N3 250V 20m\u03a9 64A TO-220 STW48NM60N 600V 70m\u03a9 44A TO-247"},{"location":"device-models/#igbts","title":"IGBTs","text":"Model V_ce V_ce(sat) I_c Package IRG4PH50UD 1200V 2.0V 45A TO-247 IKW40N120H3 1200V 1.7V 40A TO-247"},{"location":"device-models/#diodes","title":"Diodes","text":"Model V_r V_f I_f t_rr 1N4148 100V 0.7V 200mA 4ns MUR860 600V 1.0V 8A 60ns STTH30R06 600V 0.95V 30A 35ns"},{"location":"device-models/#using-library-models","title":"Using Library Models","text":"<pre><code>- type: mosfet\n  name: Q1\n  nodes: [d, g, s, 0]\n  use: IRF540N\n</code></pre> <p>Or override specific parameters:</p> <pre><code>- type: mosfet\n  name: Q1\n  nodes: [d, g, s, 0]\n  use: IRF540N\n  rds_on: 0.05\n</code></pre>"},{"location":"device-models/#model-selection-guidelines","title":"Model Selection Guidelines","text":""},{"location":"device-models/#for-fast-switching-analysis","title":"For Fast Switching Analysis","text":"<ul> <li>Use simplified models with datasheet parameters</li> <li>Include gate charge model for timing</li> <li>Enable adaptive timestep near switching events</li> </ul>"},{"location":"device-models/#for-loss-calculation","title":"For Loss Calculation","text":"<ul> <li>Use models with accurate on-state characteristics</li> <li>Include temperature dependence for thermal coupling</li> <li>Use switching energy lookup tables</li> </ul>"},{"location":"device-models/#for-emi-analysis","title":"For EMI Analysis","text":"<ul> <li>Include all parasitic capacitances</li> <li>Use short timesteps (&lt; 1/10 of rise time)</li> <li>Model PCB parasitics as lumped elements</li> </ul>"},{"location":"device-models/#for-thermal-analysis","title":"For Thermal Analysis","text":"<ul> <li>Use Foster models with 3-4 time constants</li> <li>Enable bidirectional thermal-electrical coupling</li> <li>Run for sufficient time to reach thermal steady-state</li> </ul>"},{"location":"examples-and-results/","title":"Examples and Results","text":"<p>This page focuses on practical backend runs with expected outputs and validation criteria.</p>"},{"location":"examples-and-results/#example-1-rc-step-sanity-baseline","title":"Example 1: RC Step (sanity baseline)","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --only rc_step \\\n  --output-dir benchmarks/out_rc\n</code></pre> <p>Expected behavior:</p> <ul> <li><code>V(out)</code> rises exponentially.</li> <li>very low analytical error for RC waveform.</li> <li>low rejection count and no unstable fallback loop.</li> </ul>"},{"location":"examples-and-results/#example-2-buck-converter-switching-transient","title":"Example 2: Buck Converter (switching transient)","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --only buck_converter \\\n  --output-dir benchmarks/out_buck\n</code></pre> <p>Checkpoints:</p> <ul> <li>output settles around expected duty-dependent value.</li> <li>ripple remains physically plausible for chosen L/C and switching frequency.</li> <li>telemetry does not show runaway fallback escalation.</li> </ul>"},{"location":"examples-and-results/#example-3-closed-loop-buck-controller-pwm-path","title":"Example 3: Closed-Loop Buck (controller + PWM path)","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --only buck_mosfet_nonlinear \\\n  --output-dir benchmarks/out_cl_buck\n</code></pre> <p>Checkpoints:</p> <ul> <li>duty command remains bounded in <code>[0, 1]</code>.</li> <li>output tracks reference without persistent divergence.</li> <li>control path remains deterministic between runs.</li> </ul>"},{"location":"examples-and-results/#example-4-electro-thermal-scenario","title":"Example 4: Electro-Thermal Scenario","text":"<pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_runner.py \\\n  --benchmarks benchmarks/electrothermal_benchmarks.yaml \\\n  --output-dir benchmarks/out_electrothermal\n</code></pre> <p>Checkpoints:</p> <ul> <li>device temperatures increase consistently with losses.</li> <li><code>thermal_summary.max_temperature</code> remains within design envelope.</li> <li>efficiency and loss totals are coherent with operating point.</li> </ul>"},{"location":"examples-and-results/#output-artifacts-for-automation","title":"Output Artifacts for Automation","text":"<p>Main files used in CI/regression tooling:</p> <ul> <li><code>results.json</code>: benchmark metrics and telemetry summaries</li> <li><code>results.csv</code>: tabular benchmark export</li> <li><code>parity_results.json</code>: external simulator parity metrics</li> <li><code>stress_results.json</code>: tiered stress evaluation</li> </ul>"},{"location":"examples-and-results/#minimal-resultsjson-shape","title":"Minimal <code>results.json</code> shape","text":"<pre><code>{\n  \"benchmark_id\": \"buck_converter\",\n  \"status\": \"passed\",\n  \"runtime_s\": 0.42,\n  \"steps\": 19876,\n  \"max_error\": 0.0018,\n  \"telemetry\": {\n    \"newton_iterations\": 53211,\n    \"timestep_rejections\": 21,\n    \"linear_fallbacks\": 3\n  }\n}\n</code></pre>"},{"location":"examples-and-results/#notebook-coverage","title":"Notebook Coverage","text":"<p>Reference notebooks are under <code>examples/notebooks</code> and include:</p> <ul> <li>first-contact setup</li> <li>converter design scenarios</li> <li>thermal modeling</li> <li>benchmark and validation workflows</li> </ul> <p>See Notebooks for execution details.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide takes you from a clean checkout to your first backend simulation.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>CMake 3.20+</li> <li>Ninja</li> <li>A C++ toolchain compatible with project requirements</li> </ul>"},{"location":"getting-started/#option-a-build-from-source-recommended-for-backend-development","title":"Option A: Build From Source (Recommended for backend development)","text":"<pre><code>cmake -S . -B build -G Ninja \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DPULSIM_BUILD_PYTHON=ON\ncmake --build build -j\n</code></pre> <p>Confirm that the package is importable from the local build tree:</p> <pre><code>PYTHONPATH=build/python python3 -c \"import pulsim as ps; print(ps.__version__)\"\n</code></pre>"},{"location":"getting-started/#option-b-install-package","title":"Option B: Install Package","text":"<pre><code>python3 -m pip install --upgrade pip\npython3 -m pip install pulsim\n</code></pre>"},{"location":"getting-started/#first-simulation-rc-step","title":"First Simulation (RC Step)","text":"<pre><code>PYTHONPATH=build/python python3 - &lt;&lt;'PY'\nimport pulsim as ps\n\nparser = ps.YamlParser(ps.YamlParserOptions())\ncircuit, options = parser.load(\"benchmarks/circuits/rc_step.yaml\")\n\noptions.newton_options.num_nodes = int(circuit.num_nodes())\noptions.newton_options.num_branches = int(circuit.num_branches())\noptions.step_mode = ps.StepMode.Variable\n\nsim = ps.Simulator(circuit, options)\nresult = sim.run_transient(circuit.initial_state())\n\nprint(\"success:\", result.success)\nprint(\"steps:\", result.total_steps)\nprint(\"samples:\", len(result.time))\nPY\n</code></pre> <p>Expected outcome:</p> <ul> <li><code>success: True</code></li> <li>non-zero <code>steps</code> and <code>samples</code></li> <li>monotonic RC charging behavior on <code>V(out)</code></li> </ul>"},{"location":"getting-started/#run-core-validation-commands","title":"Run Core Validation Commands","text":"<pre><code># Python runtime tests\nPYTHONPATH=build/python pytest python/tests -v --ignore=python/tests/validation\n\n# C++ core tests (if build already includes tests)\nctest --test-dir build --output-on-failure\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ol> <li>Read User Guide for canonical backend usage patterns.</li> <li>Use Examples and Results for converter scenarios.</li> <li>Add CI quality checks from Benchmarks and Parity.</li> </ol>"},{"location":"gui-component-parity/","title":"Matriz de Paridade: PulsimGui -&gt; Backend v1","text":"<p>Esta p\u00e1gina documenta a paridade entre componentes do cat\u00e1logo do PulsimGui e o backend unificado v1 usado por YAML + Python.</p> <ul> <li>Snapshot de invent\u00e1rio: <code>2026-02-22</code></li> <li>Escopo desta matriz: 34 componentes que antes eram ausentes no backend</li> <li>Resultado atual: 34/34 cobertos no backend (modelo f\u00edsico, surrogate ou virtual)</li> </ul>"},{"location":"gui-component-parity/#status-por-componente","title":"Status por componente","text":"Componente GUI Tipo YAML can\u00f4nico Representa\u00e7\u00e3o backend Status <code>BJT_NPN</code> <code>bjt_npn</code> surrogate sobre <code>mosfet</code> supported <code>BJT_PNP</code> <code>bjt_pnp</code> surrogate sobre <code>mosfet</code> supported <code>THYRISTOR</code> <code>thyristor</code> <code>switch</code> + controlador de latch/evento supported <code>TRIAC</code> <code>triac</code> <code>switch</code> + controlador bidirecional de latch/evento supported <code>SWITCH</code> <code>switch</code> dispositivo el\u00e9trico direto supported <code>FUSE</code> <code>fuse</code> <code>switch</code> + evento de trip por I\u00b2t supported <code>CIRCUIT_BREAKER</code> <code>circuit_breaker</code> <code>switch</code> + evento de overcurrent/delay supported <code>RELAY</code> <code>relay</code> par <code>switch</code> (NO/NC) + evento de bobina supported <code>OP_AMP</code> <code>op_amp</code> bloco virtual de controle supported <code>COMPARATOR</code> <code>comparator</code> bloco virtual de controle supported <code>PI_CONTROLLER</code> <code>pi_controller</code> bloco virtual de controle supported <code>PID_CONTROLLER</code> <code>pid_controller</code> bloco virtual de controle supported <code>MATH_BLOCK</code> <code>math_block</code> bloco virtual de controle supported <code>PWM_GENERATOR</code> <code>pwm_generator</code> bloco virtual de controle supported <code>INTEGRATOR</code> <code>integrator</code> bloco virtual de controle supported <code>DIFFERENTIATOR</code> <code>differentiator</code> bloco virtual de controle supported <code>LIMITER</code> <code>limiter</code> bloco virtual de controle supported <code>RATE_LIMITER</code> <code>rate_limiter</code> bloco virtual de controle supported <code>HYSTERESIS</code> <code>hysteresis</code> bloco virtual de controle supported <code>LOOKUP_TABLE</code> <code>lookup_table</code> bloco virtual de controle supported <code>TRANSFER_FUNCTION</code> <code>transfer_function</code> bloco virtual de controle supported <code>DELAY_BLOCK</code> <code>delay_block</code> bloco virtual de controle supported <code>SAMPLE_HOLD</code> <code>sample_hold</code> bloco virtual de controle supported <code>STATE_MACHINE</code> <code>state_machine</code> bloco virtual de controle supported <code>SATURABLE_INDUCTOR</code> <code>saturable_inductor</code> <code>inductor</code> + controlador virtual n\u00e3o linear supported <code>COUPLED_INDUCTOR</code> <code>coupled_inductor</code> 2x <code>inductor</code> + controlador virtual de acoplamento supported <code>SNUBBER_RC</code> <code>snubber_rc</code> macro expandida para ramo R-C supported <code>VOLTAGE_PROBE</code> <code>voltage_probe</code> instrumento virtual (sem stamp MNA) supported <code>CURRENT_PROBE</code> <code>current_probe</code> instrumento virtual (sem stamp MNA) supported <code>POWER_PROBE</code> <code>power_probe</code> instrumento virtual (sem stamp MNA) supported <code>ELECTRICAL_SCOPE</code> <code>electrical_scope</code> instrumento virtual/canais supported <code>THERMAL_SCOPE</code> <code>thermal_scope</code> instrumento virtual/canais t\u00e9rmicos supported <code>SIGNAL_MUX</code> <code>signal_mux</code> roteamento virtual supported <code>SIGNAL_DEMUX</code> <code>signal_demux</code> roteamento virtual supported"},{"location":"gui-component-parity/#notas-de-execucao","title":"Notas de execu\u00e7\u00e3o","text":"<ul> <li>Fase do scheduler mixed-domain por passo aceito:   <code>electrical -&gt; control -&gt; events -&gt; instrumentation</code>.</li> <li>Blocos virtuais n\u00e3o alteram topologia MNA.</li> <li>Estados de evento (trip/latch/contato) s\u00e3o determin\u00edsticos.</li> </ul>"},{"location":"gui-component-parity/#diagnosticos-e-compatibilidade","title":"Diagn\u00f3sticos e compatibilidade","text":"<ul> <li>Use <code>YamlParserOptions(strict=True)</code> para valida\u00e7\u00f5es de pinagem/par\u00e2metros.</li> <li>Todos os tipos da matriz acima n\u00e3o devem gerar <code>Unsupported component type</code>.</li> <li>Aliases de GUI s\u00e3o normalizados para nomes can\u00f4nicos no parser.</li> </ul>"},{"location":"gui-component-parity/#gate-de-regressao-recomendado-ci","title":"Gate de regress\u00e3o recomendado (CI)","text":"<pre><code>PYTHONPATH=build/python pytest -q python/tests/test_gui_component_parity.py\nPYTHONPATH=build/python pytest -q python/tests/test_runtime_bindings.py\n./build-test/core/pulsim_simulation_tests \"[v1][yaml][gui-parity]\"\n</code></pre>"},{"location":"migration-guide/","title":"Migration Guide: Python-Only v1 Runtime","text":"<p>This guide documents the migration to the unified v1 kernel with a Python-only user-facing runtime.</p>"},{"location":"migration-guide/#1-what-changed","title":"1. What Changed","text":""},{"location":"migration-guide/#removed-unsupported-user-surfaces","title":"Removed / Unsupported User Surfaces","text":"<ul> <li>Legacy CLI execution flow</li> <li>Legacy gRPC server/client workflow</li> <li>JSON netlist loading path</li> </ul>"},{"location":"migration-guide/#supported-user-surface","title":"Supported User Surface","text":"<ul> <li>Python package <code>pulsim</code></li> <li>YAML netlists (<code>schema: pulsim-v1</code>)</li> <li>Python benchmark/parity/stress tooling in <code>benchmarks/</code></li> </ul>"},{"location":"migration-guide/#2-netlist-migration-json-yaml","title":"2. Netlist Migration (JSON -&gt; YAML)","text":"<p>JSON loaders are no longer part of the supported runtime path.</p> <p>Use versioned YAML:</p> <pre><code>schema: pulsim-v1\nversion: 1\ncomponents:\n  - type: resistor\n    name: R1\n    nodes: [in, out]\n    value: 1k\n</code></pre>"},{"location":"migration-guide/#3-runtime-migration","title":"3. Runtime Migration","text":""},{"location":"migration-guide/#before-removed","title":"Before (removed)","text":"<ul> <li><code>pulsim</code> CLI command flows</li> <li>Remote gRPC client/server product workflow</li> </ul>"},{"location":"migration-guide/#after-supported","title":"After (supported)","text":"<pre><code>import pulsim as ps\n\nparser = ps.YamlParser(ps.YamlParserOptions())\ncircuit, options = parser.load(\"circuit.yaml\")\n\noptions.newton_options.num_nodes = int(circuit.num_nodes())\noptions.newton_options.num_branches = int(circuit.num_branches())\n\nsim = ps.Simulator(circuit, options)\nresult = sim.run_transient(circuit.initial_state())\n</code></pre>"},{"location":"migration-guide/#legacy-transient-backend-keys","title":"Legacy transient backend keys","text":"<p>No runtime suportado, a escolha de caminho transiente \u00e9 can\u00f4nica por modo:</p> <ul> <li><code>simulation.step_mode: fixed</code></li> <li><code>simulation.step_mode: variable</code></li> </ul> <p>As chaves legadas <code>simulation.backend</code> / <code>simulation.sundials</code> (e equivalentes em <code>simulation.advanced</code>) s\u00e3o tratadas apenas para diagn\u00f3stico de migra\u00e7\u00e3o.</p>"},{"location":"migration-guide/#beforeafter-legacy-backend-canonical-mode","title":"Before/After: legacy backend -&gt; canonical mode","text":"<p>Before (legacy, removed in strict migration path):</p> <pre><code>simulation:\n  backend: auto\n  sundials:\n    enabled: true\n    family: ida\n  adaptive_timestep: true\n  dt: 1e-7\n</code></pre> <p>After (canonical fixed-step native core):</p> <pre><code>simulation:\n  step_mode: fixed\n  dt: 1e-7\n  dt_min: 1e-9\n  dt_max: 1e-7\n</code></pre> <p>After (canonical variable-step native core):</p> <pre><code>simulation:\n  step_mode: variable\n  dt: 1e-7\n  dt_min: 1e-9\n  dt_max: 2e-6\n  timestep:\n    preset: power_electronics\n</code></pre> <p>If <code>strict = True</code>, legacy backend keys produce parser diagnostic <code>PULSIM_YAML_E_LEGACY_TRANSIENT_BACKEND</code>.</p>"},{"location":"migration-guide/#schema-evolution-policy-v1","title":"Schema Evolution Policy (v1)","text":"<ul> <li>Deprecated (migration window): <code>simulation.adaptive_timestep</code></li> <li>Accepted in schema <code>pulsim-v1</code>, but emits warning     <code>PULSIM_YAML_W_DEPRECATED_FIELD</code> with replacement guidance to     <code>simulation.step_mode: fixed|variable</code>.</li> <li>Removed (strict migration path): <code>simulation.backend</code>,   <code>simulation.sundials</code>, <code>simulation.advanced.backend</code>,   <code>simulation.advanced.sundials</code></li> <li>In strict mode, parser fails deterministically with     <code>PULSIM_YAML_E_LEGACY_TRANSIENT_BACKEND</code> and migration guidance.</li> </ul>"},{"location":"migration-guide/#beforeafter-procedural-compatibility-and-canonical-runtime","title":"Before/After: procedural compatibility and canonical runtime","text":"<p>Before (procedural path, still supported in migration window):</p> <pre><code>import pulsim as ps\n\ntimes, states, ok, msg = ps.run_transient(\n    circuit, 0.0, 1e-3, 1e-6, circuit.initial_state()\n)\n</code></pre> <p>After (canonical class/runtime surface):</p> <pre><code>import pulsim as ps\n\nopts = ps.SimulationOptions()\nopts.tstart = 0.0\nopts.tstop = 1e-3\nopts.dt = 1e-6\n\nsim = ps.Simulator(circuit, opts)\nresult = sim.run_transient(circuit.initial_state())\n</code></pre> <p>Both paths share the same v1 kernel semantics; prefer <code>Simulator</code> for new code.</p>"},{"location":"migration-guide/#beforeafter-expert-override-location","title":"Before/After: expert override location","text":"<p>Before (mixed top-level knobs):</p> <pre><code>simulation:\n  step_mode: variable\n  integrator: trbdf2\n  solver:\n    order: [gmres]\n</code></pre> <p>After (canonical mode + explicit expert section):</p> <pre><code>simulation:\n  step_mode: variable\n  advanced:\n    integrator: trbdf2\n    solver:\n      order: [gmres]\n      iterative:\n        preconditioner: ilut\n        max_iterations: 300\n        tolerance: 1e-8\n</code></pre>"},{"location":"migration-guide/#4-removed-apiworkflow-mapping","title":"4. Removed API/Workflow Mapping","text":"Removed workflow Replacement CLI <code>run/validate/info/sweep</code> Python runtime + <code>benchmarks/*.py</code> runners gRPC remote simulation docs Local Python runtime usage JSON netlist loader docs/tests YAML parser (<code>YamlParser</code>) Planned placeholder high-level suites Active runtime/benchmark/validation suites"},{"location":"migration-guide/#5-versioned-deprecation-timeline","title":"5. Versioned Deprecation Timeline","text":"Version Status Notes <code>v0.2.0</code> Deprecation window Python-only surface declared; legacy docs marked stale <code>v0.3.0</code> Removal Legacy CLI/gRPC/JSON user-facing guidance removed from primary docs <code>v0.4.0</code> Enforcement Supported workflows restricted to Python + YAML + benchmark/parity/stress toolchain"},{"location":"migration-guide/#6-migration-notes-pulsimgui-converter-integration","title":"6. Migration Notes: PulsimGui Converter Integration","text":""},{"location":"migration-guide/#canonicalizacao-de-tipos","title":"Canonicaliza\u00e7\u00e3o de tipos","text":"<p>O conversor do PulsimGui deve emitir tipos que o parser normaliza para IDs can\u00f4nicos (ex.: <code>OP_AMP</code> -&gt; <code>op_amp</code>, <code>PI_CONTROLLER</code> -&gt; <code>pi_controller</code>, <code>CIRCUIT_BREAKER</code> -&gt; <code>circuit_breaker</code>).</p> <p>Recomenda\u00e7\u00e3o: sempre serializar o tipo can\u00f4nico em min\u00fasculo para reduzir ambiguidade no pipeline GUI -&gt; YAML -&gt; backend.</p>"},{"location":"migration-guide/#regras-de-modelagem-no-backend","title":"Regras de modelagem no backend","text":"<ul> <li><code>bjt_npn</code> e <code>bjt_pnp</code>: surrogate interno baseado em <code>mosfet</code>.</li> <li><code>thyristor</code>, <code>triac</code>, <code>fuse</code>, <code>circuit_breaker</code>: composi\u00e7\u00e3o com <code>switch</code> e   controlador virtual/event-driven.</li> <li><code>relay</code>: composi\u00e7\u00e3o com dois <code>switch</code> (<code>NO</code>/<code>NC</code>) + controlador virtual da bobina.</li> <li><code>saturable_inductor</code>: <code>inductor</code> el\u00e9trico + controlador virtual de indut\u00e2ncia efetiva.</li> <li><code>coupled_inductor</code>: dois ramos <code>inductor</code> + controlador virtual de acoplamento.</li> <li><code>voltage_probe/current_probe/power_probe/scope/mux/demux</code>: componentes   virtuais (n\u00e3o estampam MNA).</li> </ul>"},{"location":"migration-guide/#pinagem-e-validacao","title":"Pinagem e valida\u00e7\u00e3o","text":"<p>Ative strict mode no parser durante integra\u00e7\u00e3o:</p> <pre><code>opts = ps.YamlParserOptions()\nopts.strict = True\nparser = ps.YamlParser(opts)\n</code></pre> <p>Isso garante diagn\u00f3stico est\u00e1vel para:</p> <ul> <li>pinagem inv\u00e1lida (ex.: <code>relay</code> sem <code>COM/NO/NC</code>);</li> <li>par\u00e2metros fora de faixa (ex.: <code>duty_min &gt; duty_max</code>);</li> <li>blocos de controle com configura\u00e7\u00e3o inconsistente.</li> </ul>"},{"location":"migration-guide/#gate-minimo-para-ci-do-conversor","title":"Gate m\u00ednimo para CI do conversor","text":"<pre><code>PYTHONPATH=build/python pytest -q python/tests/test_gui_component_parity.py\nPYTHONPATH=build/python pytest -q python/tests/test_runtime_bindings.py\n./build-test/core/pulsim_simulation_tests \"[v1][yaml][gui-parity]\"\n</code></pre>"},{"location":"migration-guide/#7-upgrade-checklist","title":"7. Upgrade Checklist","text":"<ol> <li>Replace any JSON netlist assets with YAML <code>pulsim-v1</code> netlists.</li> <li>Remove CLI automation and migrate to Python runners.</li> <li>Remove gRPC-dependent user scripts from active workflows.</li> <li>Update CI jobs to run Python benchmark/parity/stress scripts.</li> <li>Add GUI parity regression gate (<code>test_gui_component_parity.py</code>) in CI.</li> <li>Validate with <code>openspec validate refactor-python-only-v1-hardening --strict</code>.</li> </ol>"},{"location":"netlist-format/","title":"Pulsim Netlist Format Reference (YAML)","text":"<p>Pulsim uses a versioned YAML netlist format. This document describes the required structure, supported component types, and waveform definitions.</p>"},{"location":"netlist-format/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>schema: pulsim-v1\nversion: 1\nsimulation:\n  tstart: 0.0\n  tstop: 1e-3\n  dt: 1e-6\n  step_mode: variable\ncomponents:\n  - type: voltage_source\n    name: V1\n    nodes: [in, 0]\n    waveform: {type: dc, value: 5.0}\n  - type: resistor\n    name: R1\n    nodes: [in, out]\n    value: 1k\n</code></pre>"},{"location":"netlist-format/#required-fields","title":"Required Fields","text":"Field Type Description <code>schema</code> string Must be <code>pulsim-v1</code> <code>version</code> int Schema version (currently <code>1</code>) <code>components</code> list Component list"},{"location":"netlist-format/#optional-fields","title":"Optional Fields","text":"Field Type Description <code>simulation</code> map Simulation options <code>models</code> map Reusable component models"},{"location":"netlist-format/#components","title":"Components","text":"<p>Para a matriz completa de paridade do cat\u00e1logo do PulsimGui com status de suporte backend, veja <code>gui-component-parity</code>.</p>"},{"location":"netlist-format/#passive-components","title":"Passive Components","text":"<ul> <li>Resistor: <code>type: resistor</code> (or <code>R</code>), <code>value</code></li> <li>Capacitor: <code>type: capacitor</code> (or <code>C</code>), <code>value</code>, optional <code>ic</code></li> <li>Inductor: <code>type: inductor</code> (or <code>L</code>), <code>value</code>, optional <code>ic</code></li> </ul>"},{"location":"netlist-format/#sources","title":"Sources","text":"<ul> <li>Voltage Source: <code>type: voltage_source</code> (or <code>V</code>)</li> <li><code>waveform</code> supports <code>dc</code>, <code>pulse</code>, <code>sine</code>, <code>pwm</code></li> <li>Current Source: <code>type: current_source</code> (or <code>I</code>) with <code>value</code> (DC)</li> </ul>"},{"location":"netlist-format/#switching-devices","title":"Switching Devices","text":"<ul> <li>Ideal Diode: <code>type: diode</code> (or <code>D</code>), <code>g_on</code>, <code>g_off</code></li> <li>Ideal Switch: <code>type: switch</code> (or <code>S</code>), <code>ron</code>/<code>roff</code> or <code>g_on</code>/<code>g_off</code>, <code>initial_state</code></li> <li>Voltage-Controlled Switch: <code>type: vcswitch</code>, nodes <code>[ctrl, t1, t2]</code>, <code>v_threshold</code>, <code>g_on</code>, <code>g_off</code></li> </ul>"},{"location":"netlist-format/#power-devices","title":"Power Devices","text":"<ul> <li>MOSFET: <code>type: mosfet</code>/<code>nmos</code>/<code>pmos</code> (or <code>M</code>)</li> <li>IGBT: <code>type: igbt</code> (or <code>Q</code>)</li> </ul>"},{"location":"netlist-format/#transformer","title":"Transformer","text":"<ul> <li>Transformer: <code>type: transformer</code> (or <code>T</code>), <code>turns_ratio</code></li> </ul>"},{"location":"netlist-format/#waveforms","title":"Waveforms","text":"<pre><code>waveform:\n  type: dc\n  value: 12\n</code></pre> <pre><code>waveform:\n  type: pulse\n  v_initial: 0\n  v_pulse: 5\n  t_delay: 0\n  t_rise: 1e-9\n  t_fall: 1e-9\n  t_width: 1e-6\n  period: 2e-6\n</code></pre> <pre><code>waveform:\n  type: sine\n  amplitude: 2.5\n  frequency: 1000\n  offset: 0\n  phase: 0\n</code></pre> <pre><code>waveform:\n  type: pwm\n  v_high: 10\n  v_low: 0\n  frequency: 20000\n  duty: 0.5\n  dead_time: 1e-6\n  phase: 0\n</code></pre>"},{"location":"netlist-format/#models-and-overrides","title":"Models and Overrides","text":"<pre><code>models:\n  m1:\n    type: mosfet\n    params:\n      vth: 2.0\n      kp: 20e-6\n\ncomponents:\n  - type: mosfet\n    name: M1\n    nodes: [g, d, s]\n    use: m1\n    params:\n      kp: 40e-6  # override\n</code></pre>"},{"location":"netlist-format/#simulation-options","title":"Simulation Options","text":"<pre><code>simulation:\n  tstart: 0.0\n  tstop: 1e-3\n  dt: 1e-6\n  step_mode: variable    # fixed | variable\n  dt_min: 1e-12\n  dt_max: 1e-3\n  adaptive_timestep: true # override avan\u00e7ado; prefira step_mode\n  enable_events: true\n  enable_losses: true\n  integrator: trbdf2   # trapezoidal, bdf1, bdf2, trbdf2, rosenbrockw, sdirk2\n</code></pre> <p><code>simulation.backend</code> e <code>simulation.sundials</code> s\u00e3o chaves legadas e n\u00e3o fazem parte da superf\u00edcie suportada de transiente.</p>"},{"location":"netlist-format/#solver-configuration","title":"Solver Configuration","text":"<p>Use <code>simulation.solver</code> to control linear/iterative solver selection and nonlinear aids:</p> <pre><code>simulation:\n  solver:\n    order: [klu, gmres]\n    fallback_order: [sparselu]\n    allow_fallback: true\n    auto_select: true\n    size_threshold: 400\n    nnz_threshold: 2000\n    diag_min_threshold: 1e-12\n    preconditioner: ilut        # or amg (if available)\n    ilut_drop_tolerance: 1e-3\n    ilut_fill_factor: 10\n    iterative:\n      max_iterations: 200\n      tolerance: 1e-8\n      restart: 40\n      preconditioner: ilut      # or amg (if available)\n      ilut_drop_tolerance: 1e-3\n      ilut_fill_factor: 10\n      enable_scaling: true\n      scaling_floor: 1e-12\n    nonlinear:\n      anderson:\n        enable: true\n        depth: 5\n        beta: 0.5\n      broyden:\n        enable: false\n        max_size: 8\n      newton_krylov:\n        enable: false\n      trust_region:\n        enable: true\n        radius: 1.0\n        shrink: 0.5\n        expand: 1.2\n        min: 1e-4\n        max: 10.0\n      reuse_jacobian_pattern: true\n</code></pre> <p>You can also set Newton options directly under <code>simulation.newton</code> if preferred.</p> <pre><code>simulation:\n  newton:\n    max_iterations: 50\n    enable_newton_krylov: true\n    krylov_residual_cache_tolerance: 1e-8\n    reuse_jacobian_pattern: true\n</code></pre>"},{"location":"netlist-format/#periodic-steady-state","title":"Periodic Steady-State","text":"<pre><code>simulation:\n  shooting:\n    period: 10e-6\n    max_iterations: 30\n    tolerance: 1e-6\n    relaxation: 0.5\n    store_last_transient: true\n\n  harmonic_balance:\n    period: 10e-6\n    num_samples: 128\n    max_iterations: 40\n    tolerance: 1e-6\n    relaxation: 0.5\n    initialize_from_transient: true\n</code></pre>"},{"location":"netlist-format/#si-prefixes","title":"SI Prefixes","text":"<p>Values support SI prefixes: <code>f</code>, <code>p</code>, <code>n</code>, <code>u</code>, <code>m</code>, <code>k</code>, <code>meg</code>, <code>g</code>, <code>t</code>.</p> <p>Examples: <code>1k</code> = 1000, <code>100n</code> = 100e-9, <code>4.7u</code> = 4.7e-6.</p>"},{"location":"notebooks/","title":"Notebooks","text":"<p>Jupyter notebooks live in <code>examples/notebooks</code> and use the same backend runtime (<code>import pulsim</code>) used by scripts and CI.</p>"},{"location":"notebooks/#launch-locally","title":"Launch Locally","text":"<pre><code>PYTHONPATH=build/python python3 -m jupyter notebook\n</code></pre> <p>Recommended sequence:</p> <ul> <li><code>examples/notebooks/00_notebook_index.ipynb</code></li> <li><code>examples/notebooks/01_getting_started.ipynb</code></li> <li><code>examples/notebooks/02_buck_converter.ipynb</code></li> <li><code>examples/notebooks/03_thermal_modeling.ipynb</code></li> <li><code>examples/notebooks/10_benchmarks.ipynb</code></li> </ul> <p>Advanced catalog/coverage notebooks:</p> <ul> <li><code>15_new_components_catalog.ipynb</code></li> <li><code>16_control_blocks_mixed_domain.ipynb</code></li> <li><code>17_protection_magnetics_probes.ipynb</code></li> <li><code>18_buck_mosfet_pwm_block.ipynb</code></li> </ul>"},{"location":"notebooks/#execute-headless-cilocal-automation","title":"Execute Headless (CI/local automation)","text":"<pre><code>PYTHONPATH=build/python MPLBACKEND=Agg python3 -m nbconvert \\\n  --to notebook \\\n  --execute \\\n  --inplace \\\n  --ExecutePreprocessor.timeout=600 \\\n  examples/pulsim_tutorial.ipynb\n</code></pre>"},{"location":"notebooks/#notebook-environment-tips","title":"Notebook Environment Tips","text":"<ul> <li>Keep notebook Python ABI aligned with the built extension (e.g., <code>cp313</code>, <code>cp314</code>).</li> <li>If import fails, validate <code>PYTHONPATH=build/python</code> first.</li> <li>Prefer deterministic seeds and fixed benchmark manifests when publishing figures.</li> </ul>"},{"location":"python-api/","title":"Python API Reference","text":"<p>A superf\u00edcie suportada para usu\u00e1rios \u00e9 a API Python do m\u00f3dulo <code>pulsim</code>.</p>"},{"location":"python-api/#fluxo-principal-de-uso","title":"Fluxo principal de uso","text":"<ol> <li><code>YamlParser</code> carrega netlist e op\u00e7\u00f5es.</li> <li>Ajuste fino de <code>SimulationOptions</code> em runtime.</li> <li><code>Simulator</code> executa DC/transiente/peri\u00f3dico.</li> <li><code>SimulationResult</code> entrega sinais e telemetria.</li> </ol>"},{"location":"python-api/#tipos-principais","title":"Tipos principais","text":"Tipo Papel <code>YamlParserOptions</code>, <code>YamlParser</code> Parse/valida\u00e7\u00e3o de YAML <code>pulsim-v1</code>. <code>Circuit</code> Grafo/circuito pronto para simula\u00e7\u00e3o. <code>SimulationOptions</code> Configura\u00e7\u00e3o completa da simula\u00e7\u00e3o. <code>Simulator</code> Execu\u00e7\u00e3o de <code>dc_operating_point</code>, <code>run_transient</code>, <code>run_periodic_shooting</code>, <code>run_harmonic_balance</code>. <code>SimulationResult</code> Sinais (<code>time</code>, <code>states</code>), eventos, telemetria e resumos de perdas/t\u00e9rmico. <p>As APIs de transiente em Python (<code>Simulator.run_transient</code>, <code>run_transient_streaming</code>, <code>run_transient_shared</code> e <code>ps.run_transient</code>) aplicam perfil robusto por padr\u00e3o para reduzir falhas de converg\u00eancia.</p>"},{"location":"python-api/#compatibilidade-de-migracao","title":"Compatibilidade de migra\u00e7\u00e3o","text":"<ul> <li><code>ps.run_transient(...)</code> permanece dispon\u00edvel para compatibilidade procedural.</li> <li>A superf\u00edcie can\u00f4nica para novas integra\u00e7\u00f5es \u00e9 <code>YamlParser</code> + <code>SimulationOptions</code> + <code>Simulator</code>.</li> <li>Em casos de migra\u00e7\u00e3o YAML, prefira <code>simulation.step_mode</code> em vez de   <code>simulation.adaptive_timestep</code>/<code>simulation.backend</code>.</li> </ul>"},{"location":"python-api/#exemplo-completo","title":"Exemplo completo","text":"<pre><code>import pulsim as ps\n\nparser = ps.YamlParser(ps.YamlParserOptions())\ncircuit, options = parser.load(\"benchmarks/circuits/buck_converter.yaml\")\n\noptions.newton_options.num_nodes = int(circuit.num_nodes())\noptions.newton_options.num_branches = int(circuit.num_branches())\noptions.linear_solver = ps.LinearSolverStackConfig.defaults()\noptions.integrator = ps.Integrator.TRBDF2\noptions.step_mode = ps.StepMode.Variable\n\nsim = ps.Simulator(circuit, options)\nresult = sim.run_transient(circuit.initial_state())\n\nprint(\"success:\", result.success)\nprint(\"steps:\", result.total_steps)\nprint(\"newton_total:\", result.newton_iterations_total)\nprint(\"linear_fallbacks:\", result.linear_solver_telemetry.total_fallbacks)\nprint(\"backend_caps:\", ps.backend_capabilities())\n</code></pre>"},{"location":"python-api/#atalho-recomendado-para-transiente","title":"Atalho recomendado para transiente","text":"<p>Para uso direto em notebook, <code>ps.run_transient(...)</code> agora aplica fallback autom\u00e1tico de robustez por padr\u00e3o:</p> <ul> <li>retry com <code>dt</code> menor e mais itera\u00e7\u00f5es de Newton;</li> <li>regulariza\u00e7\u00e3o autom\u00e1tica (bleeders + clamp de n\u00e3o linearidades) em caso de falha persistente.</li> </ul> <p>Voc\u00ea pode desativar:</p> <pre><code>times, states, ok, msg = ps.run_transient(\n    ckt, t0, t1, dt, x0,\n    robust=False,\n    auto_regularize=False,\n)\n</code></pre>"},{"location":"python-api/#enums-importantes","title":"Enums importantes","text":"<ul> <li><code>Integrator</code>: <code>Trapezoidal</code>, <code>BDF1..BDF5</code>, <code>TRBDF2</code>, <code>RosenbrockW</code>, <code>SDIRK2</code></li> <li><code>LinearSolverKind</code>: <code>SparseLU</code>, <code>EnhancedSparseLU</code>, <code>KLU</code>, <code>GMRES</code>, <code>BiCGSTAB</code>, <code>CG</code></li> <li><code>PreconditionerKind</code>: <code>None_</code>, <code>Jacobi</code>, <code>ILU0</code>, <code>ILUT</code>, <code>AMG</code> (quando dispon\u00edvel)</li> <li><code>SolverStatus</code>, <code>DCStrategy</code>, <code>SimulationEventType</code>, <code>FallbackReasonCode</code></li> </ul>"},{"location":"python-api/#configuracoes-que-mais-importam","title":"Configura\u00e7\u00f5es que mais importam","text":""},{"location":"python-api/#solver-linear","title":"Solver linear","text":"<ul> <li><code>LinearSolverStackConfig.order</code></li> <li><code>LinearSolverStackConfig.fallback_order</code></li> <li><code>LinearSolverStackConfig.auto_select</code></li> <li><code>IterativeSolverConfig.preconditioner</code>, <code>max_iterations</code>, <code>tolerance</code></li> </ul>"},{"location":"python-api/#newton-e-convergencia","title":"Newton e converg\u00eancia","text":"<ul> <li><code>NewtonOptions.max_iterations</code></li> <li><code>NewtonOptions.enable_limiting</code></li> <li><code>NewtonOptions.max_voltage_step</code> / <code>max_current_step</code></li> </ul>"},{"location":"python-api/#timestep-e-integrador","title":"Timestep e integrador","text":"<ul> <li><code>SimulationOptions.step_mode</code> (<code>StepMode.Fixed</code> ou <code>StepMode.Variable</code>)</li> <li><code>SimulationOptions.integrator</code></li> <li><code>SimulationOptions.adaptive_timestep</code></li> <li><code>SimulationOptions.timestep_config</code></li> <li><code>SimulationOptions.lte_config</code></li> </ul> <p><code>SimulationOptions.transient_backend</code> e <code>SimulationOptions.sundials</code> permanecem apenas para migra\u00e7\u00e3o/diagn\u00f3stico de legado; o caminho suportado usa core nativo com <code>step_mode</code>.</p>"},{"location":"python-api/#termico-e-perdas","title":"T\u00e9rmico e perdas","text":"<ul> <li><code>SimulationOptions.enable_losses</code></li> <li><code>SimulationOptions.switching_energy</code></li> <li><code>SimulationOptions.thermal</code></li> <li><code>SimulationOptions.thermal_devices</code></li> </ul>"},{"location":"python-api/#resultados-para-analise","title":"Resultados para an\u00e1lise","text":"<p>Campos \u00fateis de <code>SimulationResult</code>:</p> <ul> <li><code>time</code>, <code>states</code></li> <li><code>events</code></li> <li><code>success</code>, <code>final_status</code>, <code>message</code></li> <li><code>newton_iterations_total</code>, <code>timestep_rejections</code></li> <li><code>linear_solver_telemetry</code>, <code>fallback_trace</code></li> <li><code>loss_summary</code>, <code>thermal_summary</code></li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#modulenotfounderror-pulsim_pulsim","title":"<code>ModuleNotFoundError: pulsim._pulsim</code>","text":"<p>Cause:</p> <ul> <li>Python cannot find the compiled extension for your interpreter ABI.</li> </ul> <p>Fix:</p> <pre><code>cmake -S . -B build -G Ninja -DPULSIM_BUILD_PYTHON=ON\ncmake --build build -j\nPYTHONPATH=build/python python3 -c \"import pulsim; print(pulsim.__version__)\"\n</code></pre>"},{"location":"troubleshooting/#modulenotfounderror-pulsimsignal_evaluator","title":"<code>ModuleNotFoundError: pulsim.signal_evaluator</code>","text":"<p>Cause:</p> <ul> <li>stale build/package path missing companion Python modules.</li> </ul> <p>Fix:</p> <ul> <li>rebuild and ensure <code>build/python/pulsim/signal_evaluator.py</code> exists;</li> <li>avoid stale <code>build/cp*/python</code> directories from old builds.</li> </ul>"},{"location":"troubleshooting/#macos-import-fails-with-clibc-symbols","title":"macOS import fails with C++/libc++ symbols","text":"<p>Cause:</p> <ul> <li>ABI mismatch when building bindings with non-Apple clang toolchain.</li> </ul> <p>Fix:</p> <ul> <li>use AppleClang for macOS Python builds (project CMake already enforces this path when possible);</li> <li>clean and rebuild.</li> </ul>"},{"location":"troubleshooting/#tests-fail-due-to-wrong-module-path","title":"Tests fail due to wrong module path","text":"<p>Cause:</p> <ul> <li>environment points to stale build artifacts.</li> </ul> <p>Fix:</p> <pre><code># Verify active module origin\npython3 - &lt;&lt;'PY'\nimport pulsim\nprint(pulsim.__file__)\nPY\n</code></pre> <p>Ensure it points to either:</p> <ul> <li>installed package in active venv/site-packages, or</li> <li>current <code>build/python/pulsim</code> tree.</li> </ul>"},{"location":"troubleshooting/#docs-build-fails-mkdocs-strict","title":"Docs build fails (<code>mkdocs --strict</code>)","text":"<p>Typical causes:</p> <ul> <li>broken links after page renaming</li> <li>missing dependencies in docs environment</li> </ul> <p>Fix:</p> <pre><code>python3 -m pip install -r docs/requirements.txt\nmkdocs build --strict\n</code></pre>"},{"location":"troubleshooting/#parity-script-fails-with-ltspice-backend","title":"Parity script fails with LTspice backend","text":"<p>Cause:</p> <ul> <li>LTspice executable path missing or incorrect.</li> </ul> <p>Fix:</p> <pre><code>PYTHONPATH=build/python python3 benchmarks/benchmark_ngspice.py \\\n  --backend ltspice \\\n  --ltspice-exe \"/Applications/LTspice.app/Contents/MacOS/LTspice\" \\\n  --output-dir benchmarks/ltspice_out\n</code></pre>"},{"location":"troubleshooting/#slow-or-unstable-switched-converter-runs","title":"Slow or unstable switched-converter runs","text":"<p>Recommendations:</p> <ul> <li>use variable timestep first;</li> <li>inspect fallback and rejection telemetry before tuning manually;</li> <li>run benchmark matrix to compare integrators and solver stacks in a controlled way.</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>PulsimCore exposes a stable backend workflow centered on the Python package <code>pulsim</code>.</p>"},{"location":"user-guide/#supported-product-surface","title":"Supported Product Surface","text":"<p>Supported:</p> <ul> <li>Python runtime (<code>import pulsim</code>)</li> <li>YAML netlists with <code>schema: pulsim-v1</code></li> <li>Benchmark/parity/stress tooling under <code>benchmarks/</code></li> </ul> <p>Not part of the supported product surface:</p> <ul> <li>Legacy CLI-first workflows</li> <li>Legacy gRPC surface as primary integration path</li> <li>JSON netlist loading as a canonical input format</li> </ul>"},{"location":"user-guide/#canonical-backend-workflow","title":"Canonical Backend Workflow","text":"<ol> <li>Build or install the Python package.</li> <li>Load a YAML netlist with <code>YamlParser</code>.</li> <li>Validate/update <code>SimulationOptions</code>.</li> <li>Run <code>Simulator(...).run_transient(...)</code>.</li> <li>Consume waveforms and telemetry.</li> </ol> <pre><code>import pulsim as ps\n\nparser = ps.YamlParser(ps.YamlParserOptions())\ncircuit, options = parser.load(\"benchmarks/circuits/rc_step.yaml\")\n\noptions.newton_options.num_nodes = int(circuit.num_nodes())\noptions.newton_options.num_branches = int(circuit.num_branches())\noptions.step_mode = ps.StepMode.Variable\n\nsim = ps.Simulator(circuit, options)\nresult = sim.run_transient(circuit.initial_state())\n</code></pre>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#1-circuit-and-topology","title":"1. Circuit and Topology","text":"<ul> <li><code>Circuit</code> holds nodes, devices, virtual channels, and runtime state.</li> <li>Parser-generated circuits are deterministic and suitable for CI reproducibility.</li> </ul>"},{"location":"user-guide/#2-simulation-options","title":"2. Simulation Options","text":"<p>Use <code>SimulationOptions</code> to control:</p> <ul> <li>time window and timestep strategy (<code>Fixed</code> vs <code>Variable</code>)</li> <li>nonlinear convergence (<code>NewtonOptions</code>)</li> <li>linear solver stack and fallback behavior</li> <li>event handling, periodic methods, and thermal coupling</li> </ul>"},{"location":"user-guide/#3-telemetry-and-diagnostics","title":"3. Telemetry and Diagnostics","text":"<p>The backend reports structured diagnostics such as:</p> <ul> <li>solver/fallback traces</li> <li>linear solver telemetry</li> <li>event metadata</li> <li>thermal summary / loss metrics</li> </ul> <p>This data should be consumed in CI gates instead of relying on visual-only inspection.</p>"},{"location":"user-guide/#recommended-configuration-baseline","title":"Recommended Configuration Baseline","text":"<p>For switched converters in production-like runs:</p> <ul> <li>start with variable timestep</li> <li>keep robust fallback policy enabled</li> <li>monitor rejection ratio and fallback causes</li> <li>add KPI regression thresholds before merging solver changes</li> </ul>"},{"location":"user-guide/#integration-tips","title":"Integration Tips","text":"<ul> <li>Always set <code>num_nodes</code> and <code>num_branches</code> when manually composing options.</li> <li>Keep YAML netlists as source-of-truth artifacts for reproducibility.</li> <li>Prefer explicit benchmark manifests instead of ad-hoc scripts in CI.</li> </ul>"},{"location":"user-guide/#where-to-go-next","title":"Where To Go Next","text":"<ul> <li>Netlist YAML Format</li> <li>Examples and Results</li> <li>Benchmarks and Parity</li> <li>Troubleshooting</li> </ul>"},{"location":"versioning-and-release/","title":"Docs Versioning and Release","text":"<p>PulsimCore documentation is published to GitHub Pages using MkDocs Material + mike.</p>"},{"location":"versioning-and-release/#publish-model","title":"Publish Model","text":"<ul> <li>Pull requests: strict docs build only (no deploy).</li> <li>Push to <code>main</code>: deploy documentation snapshot as <code>dev</code>.</li> <li>Push of release tags <code>vX.Y.Z</code>: deploy versioned docs (<code>X.Y.Z</code>) and update <code>latest</code>.</li> </ul> <p>This gives fast iteration on <code>main</code> and stable, versioned release docs.</p>"},{"location":"versioning-and-release/#manual-release-procedure","title":"Manual Release Procedure","text":"<ol> <li>Update project version metadata.</li> <li>Commit code + docs changes.</li> <li>Create and push a semantic tag.</li> </ol> <pre><code>python scripts/update_version.py 0.5.2\ngit tag v0.5.2\ngit push origin main --tags\n</code></pre>"},{"location":"versioning-and-release/#workflow-guarantees","title":"Workflow Guarantees","text":"<ul> <li><code>mkdocs build --strict</code> runs before deploy.</li> <li>invalid tag formats are rejected.</li> <li>version selector remains available in UI through <code>mike</code>.</li> </ul>"},{"location":"versioning-and-release/#github-pages-setup","title":"GitHub Pages Setup","text":"<p>In repository settings:</p> <ol> <li>Open Settings -&gt; Pages.</li> <li>Set Source to GitHub Actions.</li> <li>Keep <code>gh-pages</code> branch managed only by docs workflow/mike.</li> </ol>"},{"location":"versioning-and-release/#rollback-strategy","title":"Rollback Strategy","text":"<p>If documentation quality regresses:</p> <ol> <li>fix docs in a patch commit;</li> <li>publish a new patch tag (<code>vX.Y.(Z+1)</code>).</li> </ol> <p>Avoid force-reusing an existing published tag.</p>"}]}